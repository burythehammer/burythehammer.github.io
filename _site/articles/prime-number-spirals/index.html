<!DOCTYPE html>

<html>
	<head>
		<title>
			prime number spirals
		</title>

		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta name="description" content="An introduction to the Ulam and Sacks prime number spirals, and Javascript implementations of each.">
		<meta name="viewport" content="initial-scale=1">

		<style>
			div#header li#prime number spirals a {
				color: #3873b3;
				font-weight: bold;
			}
		</style>

		<link rel=”author” href="https://plus.google.com/109642458345919934865/">
		<link rel="stylesheet" type="text/css" href="/css/main.css">
		<link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro" rel="stylesheet" type="text/css">

		<!-- Page-specific stylesheets.  -->
		
		
			<link rel="stylesheet" type="text/css" href="/css/header.css">
		
		
			<link rel="stylesheet" type="text/css" href="/css/code_color_scheme.css">
			<link rel="stylesheet" type="text/css" href="/css/code.css">
		

		<!-- MathJax configuration. -->
		
			<script src="http://cdn.mathjax.org/mathjax/2.4-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,local/local">
			</script>
			<script>
				MathJax.Hub.Config({
					jax: ["input/TeX", "output/HTML-CSS"],
					"HTML-CSS": {
						linebreaks: {automatic: true, width: "container"}
					},
					tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
				});
			</script>
		

		<link rel="stylesheet" href="/css/post.css">
<link rel="stylesheet" href="/css/articles.css">


		<!-- Bill. -->
		<script>
			console.log("_   /|\n\\'o.O'\n=(___)=\n   U\n\nHey there.");
		</script>

		<!-- Google Analytics. -->
		<script>
			(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
			ga('create', 'UA-30847723-5', 'auto');
			ga('send', 'pageview');
		</script>
	</head>
	<body>
		<!--[if lt IE 7]>
			<p>
				You are using an <strong>outdated</strong> browser. Please
				<a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.
			</p>
		<![endif]-->

		<div id="main">
			
				<div id="header">
	<h2>λ</h2>
	<ul>
		<li id="home"><a href="/">home</a></li
		><li id="about"><a href="/about">about</a></li
		><li id="projects"><a href="/projects">projects</a></li
		><li id="articles"><a href="/articles">articles</a></li
		><li id="resume"><a href="/resume.pdf">resume</a></li
		><li id="contact"><a href="mailto:matt@burythehammer.com">contact</a></li
	></ul>
</div>

			
			<div id="meta">
	<h1>prime number spirals</h1>
	<span>01 Oct 2014</span>
	<div id="tags">
		<span>tags:</span>
		
			
				<a href="/articles/tags#math">math</a>,
			
		
			
				<a href="/articles/tags#visualizations">visualizations</a>,
			
		
			
				<a href="/articles/tags#prime numbers">prime numbers</a>,
			
		
			
		
		<a href="/articles/tags#javascript">javascript</a>
	</div>
</div>

<div id="post">
	
		<noscript>
			<p id="mathjax-warning">
				<b>Warning:</b> This post contains math blocks rendered with the <a href="http://www.mathjax.org/">MathJax</a>
				JavaScript library. If you don't enable JavaScript in your browser, none of them will display.
			</p>
		</noscript>
	
	
		<div id="toc-container"><table class="toc" id="toc"><tbody><tr><td>
<div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toc_level-1 toc_section-1">
<a data-scroll href="#tocAnchor-1-1"><span class="tocnumber">1</span> <span class="toctext">prime number spirals</span></a><ul>
<li class="toc_level-2 toc_section-2"><a data-scroll href="#tocAnchor-1-1-1"><span class="tocnumber">1.1</span> <span class="toctext">Ulam spiral</span></a></li>
<li class="toc_level-2 toc_section-3"><a data-scroll href="#tocAnchor-1-1-2"><span class="tocnumber">1.2</span> <span class="toctext">Sacks spiral</span></a></li>
</ul>
</li>
<li class="toc_level-1 toc_section-4"><a data-scroll href="#tocAnchor-1-4"><span class="tocnumber">2</span> <span class="toctext">prime-generating polynomials</span></a></li>
<li class="toc_level-1 toc_section-5">
<a data-scroll href="#tocAnchor-1-5"><span class="tocnumber">3</span> <span class="toctext">rendering the spirals</span></a><ul>
<li class="toc_level-2 toc_section-6"><a data-scroll href="#tocAnchor-1-5-1"><span class="tocnumber">3.1</span> <span class="toctext">canvas setup</span></a></li>
<li class="toc_level-2 toc_section-7"><a data-scroll href="#tocAnchor-1-5-2"><span class="tocnumber">3.2</span> <span class="toctext">Ulam algorithm</span></a></li>
<li class="toc_level-2 toc_section-8"><a data-scroll href="#tocAnchor-1-5-3"><span class="tocnumber">3.3</span> <span class="toctext">Sacks algorithm</span></a></li>
</ul>
</li>
</ul>
</td></tr></tbody></table></div>
<a data-scroll="" href="#toc-container"><h1 id="tocAnchor-1-1">prime number spirals</h1></a>
<p>Prime number spirals are visualizations of the distribution of prime numbers that underscore their frequent occurrences
along certain polynomials. They’re conceptually simple, yet create order out of the apparent chaos of primes and are
fairly beautiful. We’ll explore the Ulam and Sacks spirals, some of their underlying theory,
and algorithms to render each.</p>

<a data-scroll="" href="#toc-container"><h2 id="tocAnchor-1-1-1">Ulam spiral</h2></a>
<p>The story has it that <a href="http://en.wikipedia.org/wiki/Stanislaw_Ulam">Stanislaw Ulam</a>, a Polish-American mathematician of
<a href="http://en.wikipedia.org/wiki/Teller%E2%80%93Ulam_design">thermonuclear</a>
<a href="http://en.wikipedia.org/wiki/History_of_the_Teller%E2%80%93Ulam_design">fame</a><sup id="fnref:1"><a href="#fn:1" class="footnote" data-scroll="">1</a></sup>, sat in a presentation of a
“long and very boring paper” at a 1963 scientific conference. After some time, he began doodling (the hallmark of great
genius), first writing out the first few positive integers in a counter-clockwise spiral, and then circling all of
the prime numbers. And he noticed something that he’d later formulate as “a strongly nonrandom appearance.” Even on
a small scale – say, the first 121 integers, which form a 11x11 grid – it’s visible that many primes align along
certain diagonal lines.</p>

<p><img src="http://files.sevko.io/prime_number_spirals/small_ulam_spiral.png" alt="An Ulam spiral consisting of the first 121 natural numbers"></p>

<p>Ulam later used <a href="http://en.wikipedia.org/wiki/MANIAC_II">MANIAC II</a>, a first-generation computer built for
<a href="http://en.wikipedia.org/wiki/Los_Alamos_Scientific_Laboratory">Los Alamos National Laboratory</a> in 1957, to generate
images of the first 65,000<sup id="fnref:2"><a href="#fn:2" class="footnote" data-scroll="">2</a></sup> integers. The following spiral contains the first 360,000
(600x600):</p>

<p><img src="http://files.sevko.io/prime_number_spirals/big_ulam_spiral.png" alt="An Ulam spiral consisting of the first 360,000 natural numbers."></p>

<p>Look closely, and we see much more than just white noise.</p>

<a data-scroll="" href="#toc-container"><h2 id="tocAnchor-1-1-2">Sacks spiral</h2></a>

<p>A software engineer named Robert Sacks devised a variant of the Ulam spiral in 1994. Unlike Ulam’s, Sacks’s spiral
distributes integers along an <a href="http://en.wikipedia.org/wiki/Archimedean_spiral">Archimedean spiral</a>, or a function of
the polar form <script type="math/tex">r = a + b\theta</script>. Sacks discarded <script type="math/tex">a</script> (which just controls the offset of the starting point of the curve
from the pole) and used <script type="math/tex">b=\frac{1}{2\pi}</script>, leaving <script type="math/tex">r = \frac{\theta}{2\pi}</script>; he then plotted the squares of all
the natural numbers – <script type="math/tex">{1, 4, 9, 16, 25, ...}</script> – on the intersections of the spiral and the polar axis, and filled
in the points between squares along the spiral, drawing them equidistant from one another.</p>

<p><img src="http://files.sevko.io/prime_number_spirals/big_sacks_spiral.png" alt="A Sacks spiral consisting of the first 22,800 natural numbers."></p>

<a data-scroll="" href="#toc-container"><h1 id="tocAnchor-1-4">prime-generating polynomials</h1></a>

<p>The reason why we see ghostly diagonals is that some polynomials, informally called
<a href="http://mathworld.wolfram.com/Prime-GeneratingPolynomial.html">prime-generating polynomials</a>, have aberrantly high
occurrences of prime numbers. <script type="math/tex">n^2 + n + 41</script>, for instance, patented by
<a href="http://en.wikipedia.org/wiki/Leonhard_Euler">Leonhard Euler</a> in 1772, is prime for all <script type="math/tex">n</script> in the range <script type="math/tex">[0, 39]</script>,
yielding <script type="math/tex">43, 47, 53, 61, ..., 1523, 1601</script>. A variant is <script type="math/tex">n^2 - n + 41</script>, proposed by
<a href="http://en.wikipedia.org/wiki/Adrien-Marie_Legendre">Adrien-Marie Legendre</a> in 1798, which is prime in <script type="math/tex">[0, 40]</script>.
Here are several others, as taken at random from
<a href="http://mathworld.wolfram.com/Prime-GeneratingPolynomial.html">Wolfram Mathworld</a>:</p>

<script type="math/tex; mode=display">\frac{1}{4}(n^5 - 133n^4 + 6729n^3 - 158379n^2 + 1720294n - 6823316)\\
\frac{1}{36}(n^6 - 126n^5 + 6217n^4 - 153066n^3 + 1987786n^2 - 13055316n + 34747236)\\
n^4 - 97n^3 + 3294n^2 - 45458n + 213589\\
n^5 - 99n^4 + 3588n^3 - 56822n^2 + 348272n - 286397</script>

<p>In the case of the rectangular Ulam spiral, these polynomials appear as diagonal lines. They were known about since
1772, if not earlier, and a prime-number spiral was hinted at twice before Ulam published his. In 1932 (31 years
earlier before Ulam!), <a href="http://en.wikipedia.org/wiki/Laurence_Monroe_Klauber">Laurence M. Klauber</a>, a herpetologist
primarily focused on the study of rattlesnakes, presented a method of using a spiral grid to identify prime-generating
polynomials to the
<a href="http://en.wikipedia.org/wiki/Mathematical_Association_of_America">Mathematical Association of America</a>. The second
frequently-cited mention of prime spirals came from <a href="http://en.wikipedia.org/wiki/Arthur_C._Clarke">Arthur C. Clarke</a>,
a British science-fiction writer, whose <a href="http://en.wikipedia.org/wiki/The_City_and_the_Stars"><em>The City and the Stars</em></a>
(1956) describes a protagonist, Jeserac, as “[setting] up the matrix of all possible integers, and [starting] his
computer stringing the primes across its surface as beads might be arranged at the intersections of a mesh.” In my
opinion, the second mention is fairly ambiguous, but the fact stands that, by the time Ulam published his famous
spiral, a general understanding of prime-generating polynomials existed and people were considering ways of visualizing
them. Thus, it’s perhaps a little disingenuous to suggest that he stumbled across it when “doodling” (something
intricate) at random – there may have been some method to it.</p>

<a data-scroll="" href="#toc-container"><h1 id="tocAnchor-1-5">rendering the spirals</h1></a>

<p>I was introduced to prime number spirals about a year ago, by <a href="https://www.youtube.com/watch?v=iFuR97YcSLM">a video</a>
on the excellent <a href="https://www.youtube.com/channel/UCoxcjq-8xIDTYp3uz647V5A">Numberphile</a>. I immediately jumped
into hacking together a Python script to render the spirals on my own, because it’s both tremendously easy and very
visually rewarding. I’ll revisit the implementation, this time in Javascript. I’m not going to show all of the
necessary code (like HTML markup/CSS styles) in the interest of brevity, but the zipped files are linked to at the end
of the post.</p>

<a data-scroll="" href="#toc-container"><h2 id="tocAnchor-1-5-1">canvas setup</h2></a>

<p>Let’s outline our interface. We’ll define functions <code class="inline">ulamSpiral(numLayers)</code> and <code class="inline">sacksSpiral(numLayers)</code>, where
the argument <code class="inline">numLayers</code> is the number of revolutions in the spiral, or effectively the number of rings that it contains. Both
functions need to set the height and width of the canvas according to <code class="inline">numLayers</code>, and require a function
<code class="inline">drawPixel(x, y)</code> to plot pixels. Note that we’ll want <code class="inline">drawPixel()</code> to treat the <em>centroid</em> of the canvas as its
origin, so that <code class="inline">drawPixel(0, 0)</code> plots a point at its center and <em>not</em> the top-left corner. Because both the canvas
dimensions and the offset used by <code class="inline">drawPixel()</code> are dependent on <code class="inline">numLayers</code>, we’ll bundle them them into a function
called <code class="inline">setupCanvas()</code>.</p>

<div class="highlight"><pre><code class="language-javascript block" data-lang="javascript"><span class="kd">function</span> <span class="nx">setupCanvas</span><span class="p">(</span><span class="nx">numLayers</span><span class="p">){</span>
	<span class="s2">"use strict"</span><span class="p">;</span>

	<span class="kd">var</span> <span class="nx">sideLen</span> <span class="o">=</span> <span class="nx">numLayers</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kd">var</span> <span class="nx">canvas</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s2">"canvas"</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
	<span class="nx">canvas</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span><span class="s2">"width"</span><span class="p">,</span> <span class="nx">sideLen</span><span class="p">);</span>
	<span class="nx">canvas</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span><span class="s2">"height"</span><span class="p">,</span> <span class="nx">sideLen</span><span class="p">);</span>

	<span class="kd">var</span> <span class="nx">context</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="s2">"2d"</span><span class="p">);</span>
	<span class="k">return</span> <span class="kd">function</span> <span class="nx">drawPixel</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">){</span>
		<span class="nx">context</span><span class="p">.</span><span class="nx">fillRect</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">numLayers</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">numLayers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">};</span>
<span class="p">}</span></code></pre></div>

<p>Note that we set <code class="inline">sideLen</code> equal to <code class="inline">numLayers * 2 + 1</code>, rather than only <code class="inline">numLayers * 2</code>, because we need to account for the
row/column containing the origin of the spiral, which is not technically a ring. Now, we can use <code class="inline">setupCanvas()</code> to
both set the canvas dimensions, and return a <code class="inline">drawPixel()</code> that takes advantage of closure to access all of the
variables (<code class="inline">numLayers</code>, <code class="inline">context</code>) that it needs. Also, to draw a single pixel, we’re calling <code class="inline">fillRect()</code> with a
width and height of 1 – the canvas unfortunately doesn’t have (or perhaps just doesn’t expose) a single pixel-plotting
function. Finally, to test the primality of our values, we’ll use <a href="https://www.npmjs.org/~kenan">Kenan Yildirim</a>’s
<a href="https://www.npmjs.org/package/primality">primality</a> library, which provides <code class="inline">primality(val)</code>.</p>

<a data-scroll="" href="#toc-container"><h2 id="tocAnchor-1-5-2">Ulam algorithm</h2></a>

<p>The dull stuff aside, we can begin implementing <code class="inline">ulamSpiral()</code>. The general algorithm will run as follows:</p>

<ol>
  <li>Use variables <code class="inline">x</code>, <code class="inline">y</code>, and <code class="inline">currValue</code> to track the position and value of the current point – the “head” of the
spiral.</li>
  <li>Trace out the square spirals by incrementing/decrementing <code class="inline">x</code> and <code class="inline">y</code>, while incrementing <code class="inline">currValue</code>.</li>
  <li>After the head of the spiral moves, if <code class="inline">currValue</code> is prime, plot a pixel at (<code class="inline">x</code>, <code class="inline">y</code>).</li>
</ol>

<div class="highlight"><pre><code class="language-javascript block" data-lang="javascript"><span class="kd">function</span> <span class="nx">ulamSpiral</span><span class="p">(</span><span class="nx">numLayers</span><span class="p">){</span>
	<span class="s2">"use strict"</span><span class="p">;</span>

	<span class="kd">var</span> <span class="nx">drawPixel</span> <span class="o">=</span> <span class="nx">setupCanvas</span><span class="p">(</span><span class="nx">numLayers</span><span class="p">);</span>

	<span class="kd">var</span> <span class="nx">currValue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="kd">function</span> <span class="nx">drawLine</span><span class="p">(</span><span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">,</span> <span class="nx">len</span><span class="p">){</span>
		<span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">pixel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">pixel</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">pixel</span><span class="o">++</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="nx">primality</span><span class="p">(</span><span class="nx">currValue</span><span class="o">++</span><span class="p">)){</span>
				<span class="nx">drawPixel</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="nx">x</span> <span class="o">+=</span> <span class="nx">dx</span><span class="p">;</span>
			<span class="nx">y</span> <span class="o">+=</span> <span class="nx">dy</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">layer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">layer</span> <span class="o">&lt;=</span> <span class="nx">numLayers</span><span class="p">;</span> <span class="nx">layer</span><span class="o">++</span><span class="p">,</span> <span class="nx">len</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">){</span>
		<span class="nx">drawLine</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="nx">drawLine</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span><span class="p">);</span>
		<span class="nx">drawLine</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">len</span><span class="p">);</span>
		<span class="nx">drawLine</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>We simply iterate <code class="inline">numLayers + 1</code> times, drawing rectangular layers – the spiral – as we go. I couldn’t think of a
better solution than using a function <code class="inline">drawLine()</code>, which accepts a direction (<code class="inline">dx</code> and <code class="inline">dy</code>, one of which should be
0), and a <code class="inline">length</code> to draw four different straight lines (perhaps it can somehow be done in one elegant loop?).</p>

<a data-scroll="" href="#toc-container"><h2 id="tocAnchor-1-5-3">Sacks algorithm</h2></a>

<p>The Sacks spiral is a little more mathematically interesting because it relies (somewhat) on polar equations. Our
algorithm:</p>

<ol>
  <li>Iterate <code class="inline">numLayers</code> times.</li>
  <li>For each iteration, draw the values between the current square, <script type="math/tex">n ^ 2</script>, and the next, <script type="math/tex">n + 1 ^ 2</script>. Since
<script type="math/tex">(n + 1)^2 - n^2 = n^2 + 2n + 1 - n^2 = 2n + 1</script>, there are <script type="math/tex">2n + 1</script> points per iteration of <script type="math/tex">n</script>.</li>
  <li>Render each prime point by calculating its angle off the polar axis (the aligned squares), then its radius, or
distance from the pole, and then using trigonometry to solve for its cartesian coordinates.</li>
</ol>

<div class="highlight"><pre><code class="language-javascript block" data-lang="javascript"><span class="kd">function</span> <span class="nx">sacksSpiral</span><span class="p">(</span><span class="nx">numLayers</span><span class="p">){</span>
	<span class="s2">"use strict"</span><span class="p">;</span>

	<span class="kd">var</span> <span class="nx">drawPixel</span> <span class="o">=</span> <span class="nx">setupCanvas</span><span class="p">(</span><span class="nx">numLayers</span><span class="p">);</span>

	<span class="kd">var</span> <span class="nx">currValue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">layer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">layer</span> <span class="o">&lt;=</span> <span class="nx">numLayers</span><span class="p">;</span> <span class="nx">layer</span><span class="o">++</span><span class="p">){</span>
		<span class="kd">var</span> <span class="nx">numPoints</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">layer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="kd">var</span> <span class="nx">angle</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">/</span> <span class="nx">numPoints</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">point</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">point</span> <span class="o">&lt;=</span> <span class="nx">numPoints</span><span class="p">;</span> <span class="nx">point</span><span class="o">++</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="nx">primality</span><span class="p">(</span><span class="nx">currValue</span><span class="o">++</span><span class="p">)){</span>
				<span class="kd">var</span> <span class="nx">theta</span> <span class="o">=</span> <span class="nx">point</span> <span class="o">*</span> <span class="nx">angle</span><span class="p">;</span>
				<span class="kd">var</span> <span class="nx">radius</span> <span class="o">=</span> <span class="nx">layer</span> <span class="o">+</span> <span class="nx">point</span> <span class="o">/</span> <span class="nx">numPoints</span><span class="p">;</span>
				<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span><span class="p">(</span><span class="nx">theta</span><span class="p">)</span> <span class="o">*</span> <span class="nx">radius</span><span class="p">;</span>
				<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="nx">theta</span><span class="p">)</span> <span class="o">*</span> <span class="nx">radius</span><span class="p">;</span>
				<span class="nx">drawPixel</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">y</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>To calculate the polar angle of any point, we first solve for the angle between subsequent points
(<code class="inline">var angle = 2 * Math.PI / numPoints;</code>), and then multiply it by the fraction of the current rotation of the spiral
that the point lies at (<code class="inline">var theta = point * angle;</code>). We’ll also <code class="inline">Math.floor()</code> the coordinates sent to <code class="inline">drawPixel()</code>,
because, after the various trigonometic operations they’re likely decimals rather than integers and cause blurred
canvas reading.</p>

<p>That’s all! For more reading on prime-number spirals, I recommend this <a href="http://www.numberspiral.com/">in-depth article</a>
by Robert Sacks himself, and another <a href="http://www.dcs.gla.ac.uk/~jhw/spirals/">write-up</a> of algorithms used to render
them.</p>

<p>Download all of the source code <a href="http://files.sevko.io/prime_number_spirals/prime_number_spirals.zip">here</a>, or view it
on <a href="https://github.com/sevko/portfolio/tree/develop/visualizations/prime_number_spirals">Github</a>.</p>

<hr>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>Ulam is also well-known for contributing to the
<a href="http://en.wikipedia.org/wiki/Manhattan_Project">Manhattan Project</a>, proponing the
<a href="http://en.wikipedia.org/wiki/Monte_Carlo_method">Monte Carlo method</a> of computation, and exploring
<a href="http://en.wikipedia.org/wiki/Project_Orion_(nuclear_propulsion)">spaceships propelled by nuclear explosions</a>,
amongst a large number of other things. <a href="#fnref:1" class="reversefootnote" data-scroll="">↩</a></p>
    </li>
    <li id="fn:2">
      <p>Assuming that Ulam began rendering his spiral with the integer 1 (instead of something like 41, which is also
common), I suspect that the generated images had exactly 65,025 integers. 65,000 integers implies as many pixels,
the square root – the Ulam spiral is inherently square – of which is 254.95, which obviously isn’t a valid image
height/width. Thus, we round to 255, and square for 65,025. <a href="#fnref:2" class="reversefootnote" data-scroll="">↩</a></p>
    </li>
  </ol>
</div>

	
</div>

<section id="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript" src="http://sevko.disqus.com/embed.js"></script>
	<noscript><b id="comments-noscript">Enable JavaScript to see comments.</b></noscript>
</section>


	<script src="/js/smooth-scroll/dist/js/bind-polyfill.min.js"></script>
<script src="/js/smooth-scroll/dist/js/smooth-scroll.min.js"></script>
<script>
	smoothScroll.init({offset: 30});
</script>



		</div>

	</body>
</html>
