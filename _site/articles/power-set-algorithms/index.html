<!DOCTYPE html>

<html>
	<head>
		<title>
			power set algorithms
		</title>

		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta name="description" content="An overview of the math behind power sets, and implementation of three algorithms to generate them.">
		<meta name="viewport" content="initial-scale=1">

		<style>
			div#header li#power set algorithms a {
				color: #3873b3;
				font-weight: bold;
			}
		</style>

		<link rel=”author” href="https://plus.google.com/109642458345919934865/">
		<link rel="stylesheet" type="text/css" href="/css/main.css">
		<link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro" rel="stylesheet" type="text/css">

		<!-- Page-specific stylesheets.  -->
		
		
			<link rel="stylesheet" type="text/css" href="/css/header.css">
		
		
			<link rel="stylesheet" type="text/css" href="/css/code_color_scheme.css">
			<link rel="stylesheet" type="text/css" href="/css/code.css">
		

		<!-- MathJax configuration. -->
		
			<script src="http://cdn.mathjax.org/mathjax/2.4-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,local/local">
			</script>
			<script>
				MathJax.Hub.Config({
					jax: ["input/TeX", "output/HTML-CSS"],
					"HTML-CSS": {
						linebreaks: {automatic: true, width: "container"}
					},
					tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
				});
			</script>
		

		<link rel="stylesheet" href="/css/post.css">
<link rel="stylesheet" href="/css/articles.css">


		<!-- Bill. -->
		<script>
			console.log("_   /|\n\\'o.O'\n=(___)=\n   U\n\nHey there.");
		</script>

		<!-- Google Analytics. -->
		<script>
			(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
			ga('create', 'UA-30847723-5', 'auto');
			ga('send', 'pageview');
		</script>
	</head>
	<body>
		<!--[if lt IE 7]>
			<p>
				You are using an <strong>outdated</strong> browser. Please
				<a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.
			</p>
		<![endif]-->

		<div id="main">
			
				<div id="header">
	<h2>λ</h2>
	<ul>
		<li id="home"><a href="/">home</a></li
		><li id="about"><a href="/about">about</a></li
		><li id="projects"><a href="/projects">projects</a></li
		><li id="articles"><a href="/articles">articles</a></li
		><li id="resume"><a href="/resume.pdf">resume</a></li
		><li id="contact"><a href="mailto:matt@burythehammer.com">contact</a></li
	></ul>
</div>

			
			<div id="meta">
	<h1>power set algorithms</h1>
	<span>21 Sep 2014</span>
	<div id="tags">
		<span>tags:</span>
		
			
				<a href="/articles/tags#math">math</a>,
			
		
			
				<a href="/articles/tags#sets">sets</a>,
			
		
			
				<a href="/articles/tags#algorithms">algorithms</a>,
			
		
			
		
		<a href="/articles/tags#python">python</a>
	</div>
</div>

<div id="post">
	
		<noscript>
			<p id="mathjax-warning">
				<b>Warning:</b> This post contains math blocks rendered with the <a href="http://www.mathjax.org/">MathJax</a>
				JavaScript library. If you don't enable JavaScript in your browser, none of them will display.
			</p>
		</noscript>
	
	
		<div id="toc-container"><table class="toc" id="toc"><tbody><tr><td>
<div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toc_level-1 toc_section-1">
<a data-scroll href="#tocAnchor-1-1"><span class="tocnumber">1</span> <span class="toctext">power sets</span></a><ul>
<li class="toc_level-2 toc_section-2"><a data-scroll href="#tocAnchor-1-1-1"><span class="tocnumber">1.1</span> <span class="toctext">sets: primer</span></a></li>
<li class="toc_level-2 toc_section-3"><a data-scroll href="#tocAnchor-1-1-2"><span class="tocnumber">1.2</span> <span class="toctext">subsets and the power set</span></a></li>
<li class="toc_level-2 toc_section-4"><a data-scroll href="#tocAnchor-1-1-3"><span class="tocnumber">1.3</span> <span class="toctext">the cardinality of a power set</span></a></li>
</ul>
</li>
<li class="toc_level-1 toc_section-5">
<a data-scroll href="#tocAnchor-1-5"><span class="tocnumber">2</span> <span class="toctext">algorithm 1: recursive k-subsets</span></a><ul>
<li class="toc_level-2 toc_section-6"><a data-scroll href="#tocAnchor-1-5-1"><span class="tocnumber">2.1</span> <span class="toctext">generating k-subsets</span></a></li>
<li class="toc_level-2 toc_section-7"><a data-scroll href="#tocAnchor-1-5-2"><span class="tocnumber">2.2</span> <span class="toctext">from k-subsets to power set</span></a></li>
</ul>
</li>
<li class="toc_level-1 toc_section-8"><a data-scroll href="#tocAnchor-1-8"><span class="tocnumber">3</span> <span class="toctext">algorithm 2: iterative appending</span></a></li>
<li class="toc_level-1 toc_section-9"><a data-scroll href="#tocAnchor-1-9"><span class="tocnumber">4</span> <span class="toctext">algorithm 3: binary representation</span></a></li>
</ul>
</td></tr></tbody></table></div>
<a data-scroll="" href="#toc-container"><h1 id="tocAnchor-1-1">power sets</h1></a>
<p>The power set of a set is the set of all its subsets, or a collection of all the different combinations of items
contained in that given set: in this write-up, we’ll briefly explore the math behind power sets, and derive and compare
three different algorithms used to generate them.</p>

<a data-scroll="" href="#toc-container"><h2 id="tocAnchor-1-1-1">sets: primer</h2></a>
<p>To refresh our memories: a <a href="http://en.wikipedia.org/wiki/Set_(mathematics)">set</a>, the building block of <a href="http://en.wikipedia.org/wiki/Set_theory">set
theory</a><sup id="link1"><a href="#note1">1</a></sup>, is a collection of any number of
unique objects whose order does not matter. A set is expressed using bracket notation, like <script type="math/tex">\{1, 2, 3\}</script>, and an
empty, or <strong>null</strong>, set is represented using either of <script type="math/tex">\emptyset</script> and <script type="math/tex">\{\}</script>. Because sets are order-agnostic, we
can say that the <script type="math/tex">\{1, 2, 3\}</script> and <script type="math/tex">\{3, 1, 2\}</script> are equal, and, because they contain only distinct members,
something like <script type="math/tex">\{1, 1, 2\}</script> is invalid.</p>

<a data-scroll="" href="#toc-container"><h2 id="tocAnchor-1-1-2">subsets and the power set</h2></a>
<p>The <a href="http://en.wikipedia.org/wiki/Subset">subset</a> of a set is any combination (the null set included) of its members,
such that it is contained inside the superset; <script type="math/tex">\{a, b\}</script>, then, is a subset of <script type="math/tex">\{a, b, c\}</script>, while <script type="math/tex">\{a, d\}</script>
is not. If a subset contains <em>all</em> of the members of the parent set (ie, it’s a copy), we call it an <strong>improper</strong>
subset – otherwise, it’s <strong>proper</strong>. Finally, the <a href="http://en.wikipedia.org/wiki/Power_set">power set</a> of a set is the
collection of all of its subsets, so the power set of <script type="math/tex">\{a, b, c\}</script> is:</p>

<script type="math/tex; mode=display">\{
    \{\},
    \{a\},
    \{b\},
    \{c\},
    \{a, b\},
    \{a, c\},
    \{b, c\},
    \{a, b, c\}
\}</script>

<a data-scroll="" href="#toc-container"><h2 id="tocAnchor-1-1-3">the cardinality of a power set</h2></a>
<p>The length, or <a href="http://en.wikipedia.org/wiki/Cardinality">cardinality</a>, of a power set is <script type="math/tex">2^n</script>, where <script type="math/tex">n</script> is the
cardinality of the original set, so the number of subsets of something like <script type="math/tex">\{a, b, c\} (n=3)</script> is 8 <script type="math/tex">(2^{n=3})</script>.
Two ways of informally proving that property:</p>

<ol>
  <li>when creating a subset of a given set, we iterate over the members of the given set and choose whether each one
will or will not be in the subset. Since there are 2 possible outcomes of each choice (the member either is or
isn’t chosen) and there are <script type="math/tex">n</script> elements, there must be <script type="math/tex">2^n</script> subsets.</li>
  <li>when adding an element to a set, to update its power set, you must create a copy of each of its existing subsets
with the new element included. We’ll use this to implement our succinct second algorithm.</li>
</ol>

<p><strong>Note</strong>: the following algorithms are accompanied by Python implementations. To keep things simple, and because the
algorithms are language-independent, I avoided using Python-specific built-ins (like <code class="inline">yield</code>) and functions (like
<code class="inline">list.extend()</code>) that don’t have clear equivalents in most other languages, even though they would’ve made some code
much cleaner. Also, even though we’re dealing with sets, we’ll use lists (arrays) under the assumption that they
contain distinct elements.</p>

<a data-scroll="" href="#toc-container"><h1 id="tocAnchor-1-5">algorithm 1: recursive k-subsets</h1></a>
<p>This was my first stab at an algorithm that, given a set, returns its power set, and surprise! It’s the least
intuitive and most inelegant of the three. We begin by writing a recursive function <code class="inline">k_subsets()</code> to find all of a
set’s subsets of cardinality <script type="math/tex">k</script> (a.k.a. its <a href="http://mathworld.wolfram.com/k-Subset.html"><script type="math/tex">k</script>-subsets</a>):</p>

<a data-scroll="" href="#toc-container"><h2 id="tocAnchor-1-5-1">generating k-subsets</h2></a>

<ol>
  <li>Given a set of length <script type="math/tex">n</script> and a desired subset of length <script type="math/tex">k</script>, iterate over the first <script type="math/tex">n - k + 1</script> elements.</li>
  <li>For each element, make a recursive call to retrieve the <script type="math/tex">(k-1)</script>-subsets for the remainder of the array (all
elements after the current one).</li>
  <li>Append the element to each <script type="math/tex">(k-1)</script>-subset, and return these subsets.</li>
</ol>

<div class="highlight"><pre><code class="language-python block" data-lang="python"><span class="k">def</span> <span class="nf">k_subsets</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">set_</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[[]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">subsets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">set_</span><span class="p">)</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="n">k_subsets</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">set_</span><span class="p">[</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]):</span>
                <span class="n">subsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subset</span> <span class="o">+</span> <span class="p">[</span><span class="n">set_</span><span class="p">[</span><span class="n">ind</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">subsets</span></code></pre></div>

<a data-scroll="" href="#toc-container"><h2 id="tocAnchor-1-5-2">from k-subsets to power set</h2></a>

<p>With the ability to generate any <script type="math/tex">k</script>-subset, the key to creating a power set is finding the <script type="math/tex">k</script>-subsets for all
valid <script type="math/tex">k</script>, which lie in the range <script type="math/tex">[0, n]</script> (<script type="math/tex">n</script>, again, is the cardinality of the superset)!</p>

<ol>
  <li>For any <script type="math/tex">k</script> in <script type="math/tex">[0, n]</script>:</li>
  <li>find the set’s <script type="math/tex">k</script>-subsets</li>
</ol>

<p>We’ll introduce a wrapper function, <code class="inline">power_set()</code>, in which we’ll nest a slightly modified <code class="inline">k_subsets()</code> that takes
advantage of closures.</p>

<div class="highlight"><pre><code class="language-python block" data-lang="python"><span class="k">def</span> <span class="nf">power_set_1</span><span class="p">(</span><span class="n">set_</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">k_subsets</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">start_ind</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[[]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subsets</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">start_ind</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">set_</span><span class="p">)</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="n">k_subsets</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">subsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subset</span> <span class="o">+</span> <span class="p">[</span><span class="n">set_</span><span class="p">[</span><span class="n">ind</span><span class="p">]])</span>
            <span class="k">return</span> <span class="n">subsets</span>

    <span class="n">subsets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">set_</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="n">k_subsets</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">subsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">subsets</span></code></pre></div>

<a data-scroll="" href="#toc-container"><h1 id="tocAnchor-1-8">algorithm 2: iterative appending</h1></a>

<p>The second algorithm relies on our second informal proof of sets’ cardinality: whenever an element is added to a set,
it must be added to copies of all the subsets in its current power set to form the new one. Thus:</p>

<ol>
  <li>Start with an empty set, <script type="math/tex">\{\}</script>, and its power-set, <script type="math/tex">\{\{\}\}</script>.</li>
  <li>For every element inside the superset:</li>
  <li>Create a copy of every set in the current power-set</li>
  <li>Add the element to each one.</li>
  <li>Add the copies to the current power-set.</li>
</ol>

<p>Like so:</p>

<div class="highlight"><pre><code class="language-python block" data-lang="python"><span class="k">def</span> <span class="nf">power_set_2</span><span class="p">(</span><span class="n">set_</span><span class="p">):</span>
    <span class="n">subsets</span> <span class="o">=</span> <span class="p">[[]]</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">set_</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subsets</span><span class="p">)):</span>
            <span class="n">subsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subsets</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">element</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">subsets</span></code></pre></div>

<a data-scroll="" href="#toc-container"><h1 id="tocAnchor-1-9">algorithm 3: binary representation</h1></a>

<p>The third algorithm is a clever hack, and relies on the binary representation of an incremented number to construct
subsets. In our first proof of the cardinality of a power set, we iterated over each element of an argument set and
made a choice with two possible outcomes (the element either was or wasn’t a member of the subset): <script type="math/tex">\underbrace{2 \times 2 \times ... \times 2}_{n} = 2^n</script>. Let’s consider an integer of <script type="math/tex">n</script>-bits: it has <script type="math/tex">2^n</script>
possible values in the range <script type="math/tex">[0, 2^n - 1]</script>, meaning that we can use it to represent <script type="math/tex">2^n</script> distinct arrangements of
<script type="math/tex">n</script> bits. Hmm…</p>

<ol>
  <li>Iterate over the range <script type="math/tex">[0, 2^n - 1]</script>.</li>
  <li>For every value, examine each of its <script type="math/tex">n</script> bits.</li>
  <li>If the <script type="math/tex">k</script>th bit has a value of 1, add the <script type="math/tex">k</script>th value of the superset to the current subset.</li>
</ol>

<div class="highlight"><pre><code class="language-python block" data-lang="python"><span class="k">def</span> <span class="nf">is_bit_flipped</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">bit</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;&gt;</span> <span class="n">bit</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">power_set_3</span><span class="p">(</span><span class="n">set_</span><span class="p">):</span>
    <span class="n">subsets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="nb">len</span><span class="p">(</span><span class="n">set_</span><span class="p">)):</span>
        <span class="n">new_subset</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">set_</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">is_bit_flipped</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">bit</span><span class="p">):</span>
                <span class="n">new_subset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">set_</span><span class="p">[</span><span class="n">bit</span><span class="p">])</span>
        <span class="n">subsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_subset</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">subsets</span></code></pre></div>

<hr>

<p><span id="note1"><a href="#link1">1</a></span>: (completely tangentially) whenever I mention set theory I can’t help but think of
the infamous <a href="http://en.wikipedia.org/wiki/Principia_Mathematica">Principia Mathematica</a>: a staggering, three-volume
attempt to axiomatize all of mathematics, published by <a href="http://en.wikipedia.org/wiki/Bertrand_Russell">Bertrand
Russell</a> and <a href="http://en.wikipedia.org/wiki/Alfred_North_Whitehead">Alfred North
Whitehead</a> in 1910-‘13, that relied heavily on sets. It’s
notorious, amongst other things, for proving <script type="math/tex">1 + 1 = 2</script> in no less than 379 pages. Check it out.</p>

	
</div>

<section id="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript" src="http://sevko.disqus.com/embed.js"></script>
	<noscript><b id="comments-noscript">Enable JavaScript to see comments.</b></noscript>
</section>


	<script src="/js/smooth-scroll/dist/js/bind-polyfill.min.js"></script>
<script src="/js/smooth-scroll/dist/js/smooth-scroll.min.js"></script>
<script>
	smoothScroll.init({offset: 30});
</script>



		</div>

	</body>
</html>
