<!DOCTYPE html>

<html>
	<head>
		<title>
			RSA: implementation and proofs
		</title>

		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta name="description" content="A Python implementation of RSA, and proofs of the algorithms it uses.">
		<meta name="viewport" content="initial-scale=1">

		<style>
			div#header li#RSA: implementation and proofs a {
				color: #3873b3;
				font-weight: bold;
			}
		</style>

		<link rel=”author” href="https://plus.google.com/109642458345919934865/">
		<link rel="stylesheet" type="text/css" href="/css/main.css">
		<link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro" rel="stylesheet" type="text/css">

		<!-- Page-specific stylesheets.  -->
		
		
			<link rel="stylesheet" type="text/css" href="/css/header.css">
		
		
			<link rel="stylesheet" type="text/css" href="/css/code_color_scheme.css">
			<link rel="stylesheet" type="text/css" href="/css/code.css">
		

		<!-- MathJax configuration. -->
		
			<script src="http://cdn.mathjax.org/mathjax/2.4-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,local/local">
			</script>
			<script>
				MathJax.Hub.Config({
					jax: ["input/TeX", "output/HTML-CSS"],
					"HTML-CSS": {
						linebreaks: {automatic: true, width: "container"}
					},
					tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
				});
			</script>
		

		<link rel="stylesheet" href="/css/post.css">
<link rel="stylesheet" href="/css/articles.css">


		<!-- Bill. -->
		<script>
			console.log("_   /|\n\\'o.O'\n=(___)=\n   U\n\nHey there.");
		</script>

		<!-- Google Analytics. -->
		<script>
			(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
			ga('create', 'UA-30847723-5', 'auto');
			ga('send', 'pageview');
		</script>
	</head>
	<body>
		<!--[if lt IE 7]>
			<p>
				You are using an <strong>outdated</strong> browser. Please
				<a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.
			</p>
		<![endif]-->

		<div id="main">
			
				<div id="header">
	<h2>λ</h2>
	<ul>
		<li id="home"><a href="/">home</a></li
		><li id="about"><a href="/about">about</a></li
		><li id="projects"><a href="/projects">projects</a></li
		><li id="articles"><a href="/articles">articles</a></li
		><li id="resume"><a href="/resume.pdf">resume</a></li
		><li id="contact"><a href="mailto:matt@burythehammer.com">contact</a></li
	></ul>
</div>

			
			<div id="meta">
	<h1>RSA: implementation and proofs</h1>
	<span>14 Jun 2015</span>
	<div id="tags">
		<span>tags:</span>
		
			
				<a href="/articles/tags#math">math</a>,
			
		
			
				<a href="/articles/tags#prime numbers">prime numbers</a>,
			
		
			
				<a href="/articles/tags#algorithms">algorithms</a>,
			
		
			
				<a href="/articles/tags#python">python</a>,
			
		
			
		
		<a href="/articles/tags#number theory">number theory</a>
	</div>
</div>

<div id="post">
	
		<noscript>
			<p id="mathjax-warning">
				<b>Warning:</b> This post contains math blocks rendered with the <a href="http://www.mathjax.org/">MathJax</a>
				JavaScript library. If you don't enable JavaScript in your browser, none of them will display.
			</p>
		</noscript>
	
	
		<div id="toc-container"><table class="toc" id="toc"><tbody><tr><td>
<div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toc_level-1 toc_section-1"><a data-scroll href="#tocAnchor-1-1"><span class="tocnumber">1</span> <span class="toctext">what is RSA?</span></a></li>
<li class="toc_level-1 toc_section-2"><a data-scroll href="#tocAnchor-1-2"><span class="tocnumber">2</span> <span class="toctext">math precursor</span></a></li>
<li class="toc_level-1 toc_section-3"><a data-scroll href="#tocAnchor-1-3"><span class="tocnumber">3</span> <span class="toctext">how RSA works</span></a></li>
<li class="toc_level-1 toc_section-4">
<a data-scroll href="#tocAnchor-1-4"><span class="tocnumber">4</span> <span class="toctext">generate a key-pair</span></a><ul>
<li class="toc_level-2 toc_section-5"><a data-scroll href="#tocAnchor-1-4-1"><span class="tocnumber">4.1</span> <span class="toctext">example</span></a></li>
<li class="toc_level-2 toc_section-6"><a data-scroll href="#tocAnchor-1-4-2"><span class="tocnumber">4.2</span> <span class="toctext">finding <script type="math/tex">\phi(n)</script></span></a></li>
<li class="toc_level-2 toc_section-7"><a data-scroll href="#tocAnchor-1-4-3"><span class="tocnumber">4.3</span> <span class="toctext">computing GCDs</span></a></li>
<li class="toc_level-2 toc_section-8"><a data-scroll href="#tocAnchor-1-4-4"><span class="tocnumber">4.4</span> <span class="toctext">finding modular inverses</span></a></li>
<li class="toc_level-2 toc_section-9"><a data-scroll href="#tocAnchor-1-4-5"><span class="tocnumber">4.5</span> <span class="toctext">generating large, random primes</span></a></li>
<li class="toc_level-2 toc_section-10"><a data-scroll href="#tocAnchor-1-4-6"><span class="tocnumber">4.6</span> <span class="toctext">wrapping it all up</span></a></li>
</ul>
</li>
<li class="toc_level-1 toc_section-11">
<a data-scroll href="#tocAnchor-1-11"><span class="tocnumber">5</span> <span class="toctext">encrypt/decrypt messages</span></a><ul><li class="toc_level-2 toc_section-12"><a data-scroll href="#tocAnchor-1-11-1"><span class="tocnumber">5.1</span> <span class="toctext">exponentiation by squaring</span></a></li></ul>
</li>
<li class="toc_level-1 toc_section-13"><a data-scroll href="#tocAnchor-1-13"><span class="tocnumber">6</span> <span class="toctext">acknowledgements</span></a></li>
</ul>
</td></tr></tbody></table></div>
<a data-scroll="" href="#toc-container"><h1 id="tocAnchor-1-1">what is RSA?</h1></a>
<p><a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> is a <em>public-key</em>, or <em>asymmetric</em>, encryption algorithm.
In contrast to <em>symmetric</em> algorithms, like <a href="https://en.wikipedia.org/wiki/Data_Encryption_Standard">DES</a> and
<a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a>, which use the same key for both encryption and
decryption, RSA employs two distinct keys: a <strong>public</strong> key used to encrypt data, and a <strong>private key</strong> used to
decrypt whatever was encrypted with the public one. The beauty of public-key encryption is that the parties involved
never need to exchange a master key, meaning that communications can be securely encrypted without any prior contact.</p>

<p>Public-key encryption was proposed by <a href="https://en.wikipedia.org/wiki/Whitfield_Diffie">Whitfield Diffie</a> and <a href="https://en.wikipedia.org/wiki/Martin_Hellman">Martin
Hellman</a> in ‘76, while RSA itself was patented in ‘77 by <a href="https://en.wikipedia.org/wiki/Ron_Rivest">Ron
<strong>R</strong>ivest</a>, <a href="https://en.wikipedia.org/wiki/Adi_Shamir">Adi <strong>S</strong>hamir</a>, and
<a href="https://en.wikipedia.org/wiki/Leonard_Adleman">Leonard <strong>A</strong>dleman</a>, who then went on to found a
cybersecurity <a href="https://en.wikipedia.org/wiki/RSA_Security">company</a> of the same name – confusing, but great PR!</p>

<p><img src="http://files.sevko.io/rsa/rivest_shamir_adleman.png" alt="Rivest, Shamir, and Adleman"></p>

<p><a href="https://en.wikipedia.org/wiki/Clifford_Cocks">Clifford Cocks</a>, an English cryptographer, arrived at a similar
algorithm in ‘73 while working for British intelligence at
<a href="https://en.wikipedia.org/wiki/Government_Communications_Headquarters">GHCQ</a>, but his work wasn’t declassified until
1998 due to its sensitivity. Forty years later, RSA underpins SSL certification, SSH handshakes, and lots more.</p>

<p>In this post, we’ll implement RSA, but we’ll very much take the long way around while doing so. The algorithm
introduces a number of interesting problems, like finding greatest common divisors, performing modular exponentiation,
computing modular inverses, and generating random prime numbers, each of which we’ll thoroughly explore and derive
solutions to (many of these won’t be immediately clear, so we’ll formally prove them as we go). Note that we won’t
prove RSA itself – I might add that as an extension to the article at some point in the future.</p>

<a data-scroll="" href="#toc-container"><h1 id="tocAnchor-1-2">math precursor</h1></a>
<p><script type="math/tex">\def \imod {\text{ mod }}
\def \divs {\text{ } \vert \text{ }}</script> The only thing we need to know before diving into RSA is some <a href="https://en.wikipedia.org/wiki/Modular_arithmetic">modular
arithmetic</a>, which is simply arithmetic with the property that
numbers have a maximum value (called the <em>modulus</em>) and wrap around to 0 when they exceed it. When we take a number
<script type="math/tex">a \imod b</script>, we’re basically taking the remainder of <script type="math/tex">\frac{a}{b}</script>; most programming languages provide this in the
form of a <code class="inline">mod</code> function or <code class="inline">%</code> operator. We’ll see lots of expressions in the form of:</p>

<script type="math/tex; mode=display">a \equiv b \pmod c</script>

<p>Here, the <script type="math/tex">\equiv</script> symbol implies <em>congruence</em>, or that <script type="math/tex">a \text{ mod } c</script> equals <script type="math/tex">b \text{ mod } c</script>. An
important gotcha is that <script type="math/tex">\pmod c</script> applies to <em>both</em> sides of the expression, which isn’t immediately obvious to
anyone used to the modulo operator in the programming sense. Many sources choose to omit the parentheses, simply
writing <script type="math/tex">a \equiv b \imod c</script>, which just compounds the confusion; the clearest notation would probably be something
like <script type="math/tex">(a \equiv b) \pmod c</script>. This is extremely important to remember because otherwise, expressions like <script type="math/tex">a \equiv 1
\imod b</script> won’t make any sense at all (“but if <script type="math/tex">1 \imod b</script> is equal to 1 for all <script type="math/tex">b</script> not equal to 1, why not just
write <script type="math/tex">a = 1</script>?!”).</p>

<p>Some notes about miscellaneous notation:</p>

<ol>
  <li>
<script type="math/tex">a \divs b</script> means that <script type="math/tex">a</script> divides, or is a factor of, <script type="math/tex">b</script>
</li>
  <li>range notation is used here and there: <script type="math/tex">[a, b]</script> represents all of the numbers between <script type="math/tex">a</script> and <script type="math/tex">b</script> inclusive,
<script type="math/tex">[a, b)</script> includes <script type="math/tex">a</script> but excludes <script type="math/tex">b</script>, <script type="math/tex">(a, b)</script> excludes both <script type="math/tex">a</script> <em>and</em> <script type="math/tex">b</script>, etc.</li>
</ol>

<a data-scroll="" href="#toc-container"><h1 id="tocAnchor-1-3">how RSA works</h1></a>
<p>RSA revolves around a numeric key-pair, or a mathematically related public and private key. The public key is made
known to the world, which can then use it to encrypt a message, while the private key can be used to decrypt anything
encrypted with the public key. Encrypting and decrypting a message is fairly straightforward, while generating a
key-pair is a more substantial process.</p>

<a data-scroll="" href="#toc-container"><h1 id="tocAnchor-1-4">generate a key-pair</h1></a>
<p>To generate a public/private key-pair:</p>

<ol>
  <li>generate two (large) random primes, <script type="math/tex">p</script> and <script type="math/tex">q</script>
</li>
  <li>let <script type="math/tex">n = pq</script>
</li>
  <li>find <script type="math/tex">\phi(n)</script> (<a href="https://en.wikipedia.org/wiki/Euler's_totient_function">Euler’s totient</a>), or the number of
integers in the range <script type="math/tex">[1, n]</script> that are coprime with <script type="math/tex">n</script> – that is, have a Greatest Common Divisor (GCD) of 1
with it.</li>
  <li>find a value <script type="math/tex">e</script> such that <script type="math/tex">1 \lt e \lt \phi(n)</script> and <script type="math/tex">e</script> is coprime with <script type="math/tex">\phi(n)</script>; this is your <strong>public
key</strong>.</li>
  <li>find a value <script type="math/tex">d</script> such that <script type="math/tex">de \equiv 1 \pmod{\phi(n)}</script> – in other words, find the <a href="https://en.wikipedia.org/wiki/Modular_multiplicative_inverse">multiplicative modular
inverse</a> of <script type="math/tex">e</script> modulo <script type="math/tex">\phi(n)</script>; this is your
<strong>private key</strong>.</li>
</ol>

<p>Though short and concise, the above steps present several complex problems:</p>

<ol>
  <li>generate a large, random prime number; this is probably the most involved, so we’ll save it for last (<strong>step 1</strong>)</li>
  <li>find <script type="math/tex">\phi(n)</script>, where <script type="math/tex">n</script> is the product of two primes (<strong>step 3</strong>)</li>
  <li>find the GCD of two numbers, which will allow us to find <script type="math/tex">e</script> (<strong>step 4</strong>)</li>
  <li>find the multiplicative modular inverse of a value, to find <script type="math/tex">d</script> (<strong>step 4</strong>)</li>
</ol>

<a data-scroll="" href="#toc-container"><h2 id="tocAnchor-1-4-1">example</h2></a>
<p>Before we dive into solving those, let’s walk through the process of generating a key-pair using some small sample
numbers.</p>

<ol>
  <li>let $p = 3$ and $q = 5$</li>
  <li>$n = 3 \cdot 5 = 15$</li>
  <li>$\phi(15) = 8$ (coprime values are 1, 2, 4, 7, 8, 11, 13, and 14)</li>
  <li>$e = 3$, because 3 is both less than and coprime with 8</li>
  <li>$d = 3$, because <script type="math/tex">3 \cdot 3 = 9</script> and <script type="math/tex">9 \equiv 1 \pmod 8</script>
</li>
</ol>

<p>Easy! Except, of course, we weren’t dealing with numbers with hundreds of digits – that’s the hard part. :)</p>

<a data-scroll="" href="#toc-container"><h2 id="tocAnchor-1-4-2">finding <script type="math/tex">\phi(n)</script>
</h2></a>
<p>To compute <script type="math/tex">\phi(n)</script>, we can take advantage of the fact that it’s composed of two <strong>prime</strong> factors: <script type="math/tex">p</script> and <script type="math/tex">q</script>.
Thus, the only values with which it shares GCDs that aren’t 1 must be multiples of either <script type="math/tex">p</script> or <script type="math/tex">q</script> (for instance,
<script type="math/tex">\gcd(n, 2q) = q</script> and <script type="math/tex">\gcd(n, 3p) = p</script>). There are only <script type="math/tex">q</script> multiples of <script type="math/tex">p</script> (<script type="math/tex">p, 2p, 3p, \ldots, qp</script>) and
<script type="math/tex">p</script> multiples of <script type="math/tex">q</script> (<script type="math/tex">q, 2q, 3q, \ldots, qp</script>) that are less than or equal to <script type="math/tex">n</script>. Thus, there are <script type="math/tex">q + p</script>
values in the range <script type="math/tex">[1, n]</script> that have a GCD with <script type="math/tex">n</script> not equal to 1. Note, however, that we double counted <script type="math/tex">pq</script>
in our list of multiples of <script type="math/tex">p</script> and <script type="math/tex">q</script>, so in reality it’s <script type="math/tex">p + q - 1</script>. Thus, <script type="math/tex">\phi(n) = \text{total} - (p + q
-1)</script>, where <script type="math/tex">\text{total}</script> is the total numbers of values in the range <script type="math/tex">[1, n]</script> – that is, <script type="math/tex">n</script>.</p>

<script type="math/tex; mode=display">\phi(n) = n - (p + q - 1) = n - p - q + 1</script>

<a data-scroll="" href="#toc-container"><h2 id="tocAnchor-1-4-3">computing GCDs</h2></a>
<p>To find the GCD of two numbers, we’ll employ the <a href="https://en.wikipedia.org/?title=Euclidean_algorithm">Euclidean
algorithm</a>:</p>

<ol>
  <li>the GCD of any number and 0 is the absolute value of that number</li>
  <li>the GCD of numbers <script type="math/tex">a</script> and <script type="math/tex">b</script> is the GCD of <script type="math/tex">b</script> and <script type="math/tex">(a \text{ mod } b)</script>
</li>
</ol>

<p>or:</p>

<div class="highlight"><pre><code class="language-python block" data-lang="python"><span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">)</span></code></pre></div>

<p>Let’s prove it. Case 1 should be self-explanatory: 0 is technically divisible by any number, even if the quotient
equals 0, so the GCD of 0 and any other number should be that number. We need to be careful and take its absolute
value, however, to account for negative values; the greatest divisor of -5 is 5, after all, not -5, so the
GCD of 0 and -5 must also be 5. Thus, we have to take the absolute value of -5 to arrive at the greatest divisor.</p>

<p>Case 2 is less intuitive (at least for me), and requires proving that <script type="math/tex">\gcd(a, b) = \gcd(b, a \imod b)</script>. Let’s begin
by creating another variable <script type="math/tex">c</script>:</p>

<script type="math/tex; mode=display">c = a - b</script>

<h3 id="prove-gcda-b-divs-c">prove <script type="math/tex">\gcd(a, b) \divs c</script>
</h3>
<p>We first want to prove that the GCD of <script type="math/tex">a</script> and <script type="math/tex">b</script> divides <script type="math/tex">c</script> (or <script type="math/tex">\gcd(a, b) \divs c</script>). Begin by rewriting
<script type="math/tex">a</script> and <script type="math/tex">b</script> as products of their GCD.</p>

<script type="math/tex; mode=display">a = x \cdot \gcd(a, b)\\
b = y \cdot \gcd(a, b)\\</script>

<p><script type="math/tex">x</script> and <script type="math/tex">y</script> are just placeholders: we don’t want to know or care what they equal. Now, plug those into the
definition of <script type="math/tex">c</script>:</p>

<script type="math/tex; mode=display">c = a - b\\
c = x \cdot \gcd(a, b) - y \cdot \gcd(a, b) = (x - y) \gcd(a, b)\\
\therefore \gcd(a, b) \divs c</script>

<p>Since we’ve shown that <script type="math/tex">c</script> is the product of <script type="math/tex">\gcd(a, b)</script> and another value, it is by definition divisible by
<script type="math/tex">\gcd(a, b)</script>.</p>

<h3 id="prove-gcdb-c-divs-a">prove <script type="math/tex">\gcd(b, c) \divs a</script>
</h3>
<p>Apply the same logic here:</p>

<script type="math/tex; mode=display">b = x \cdot \gcd(b, c)\\
c = y \cdot \gcd(b, c)\\
a = c + b\\
a = x \cdot \gcd(b, c) + y \cdot \gcd(b, c) = (x + y) \gcd(b, c)\\
\therefore \gcd(b, c) \divs a</script>

<h3 id="prove-gcda-b--gcdb-a---b">prove <script type="math/tex">\gcd(a, b) = \gcd(b, a - b)</script>
</h3>
<p>We know that, by definition, <script type="math/tex">\gcd(a, b) \divs b</script>, and we’ve proven that <script type="math/tex">\gcd(a, b) \divs c</script>. Thus, <script type="math/tex">\gcd(a, b)</script>
is a <em>common divisor</em> of both <script type="math/tex">b</script> and <script type="math/tex">c</script>. That doesn’t imply that it’s the least common divisor, greatest, or
anything else: all we know is that it divides both numbers. We <em>do</em> know that there exists a <strong>greatest</strong> common
divisor of <script type="math/tex">b</script> and <script type="math/tex">c</script>, <script type="math/tex">\gcd(b, c)</script>, so we can conclude that:</p>

<script type="math/tex; mode=display">\gcd(a, b) \le \gcd(b, c)</script>

<p>We now re-apply that same reasoning. We know that <script type="math/tex">\gcd(b, c) \divs b</script> and <script type="math/tex">\gcd(b, c) \divs a</script>. Thus, <script type="math/tex">\gcd(b,
c)</script> is a common divisor of <script type="math/tex">b</script> and <script type="math/tex">a</script>. Since we know that the <strong>greatest</strong> common divisor of <script type="math/tex">a</script> and <script type="math/tex">b</script> is
<script type="math/tex">\gcd(a, b)</script>, we can conclude that:</p>

<script type="math/tex; mode=display">\gcd(b, c) \le \gcd(a, b)</script>

<p>But now we have two almost contradictory conclusions:</p>

<script type="math/tex; mode=display">\gcd(a, b) \le \gcd(b, c)\\
\gcd(b, c) \le \gcd(a, b)</script>

<p>The only way these can both be true is if:</p>

<script type="math/tex; mode=display">\gcd(a, b) = \gcd(b, c)</script>

<p>So we’ve proven that <script type="math/tex">\gcd(a, b) = \gcd(b, a - b)</script> (remember, <script type="math/tex">c = a - b</script>).</p>

<h3 id="prove-gcdb-a---b--gcdb-a-imod-b">prove <script type="math/tex">\gcd(b, a - b) = \gcd(b, a \imod b)</script>
</h3>
<p>First, let’s assume that <script type="math/tex">a > b</script>, and rewrite it as: <script type="math/tex">a = bq + r</script> (or <script type="math/tex">r = a \imod b</script>)</p>

<p>Now, we already know that <script type="math/tex">\gcd(a, b) = \gcd(b, a - b)</script>, Since order doesn’t matter, we can rewrite <script type="math/tex">\gcd(b, a -
b)</script> as <script type="math/tex">\gcd(a - b, b)</script>. Now, we apply the rule <script type="math/tex">\gcd(a, b) = \gcd(b, a - b)</script> again.</p>

<script type="math/tex; mode=display">\gcd(a, b) = \gcd(b, a - b) = \gcd(a - b, b)\\
\gcd(a - b, b) = \gcd(b, a - b - b) = \gcd(a - 2b, b)\\
\gcd(a - 2b, b) = \gcd(b, a - 2b - b) = \gcd(a - 3b, b)\\
\gcd(a - 3b, b) = \gcd(b, a - 3b - b) = \gcd(a - 4b, b)\\
\ldots\\
\gcd(a - qb, b) = \gcd(r, b)</script>

<p>or:</p>

<script type="math/tex; mode=display">\gcd(a, b) = \gcd(a - b, b) = \gcd(a - 2b, b) = \ldots = \gcd(a - qb, b) = \gcd(r, b)</script>

<p>Bingo. We’ve proven Case 2, and completed our proof of the Euclidean Algorithm. Before we move on, we’ll also define a
convenience wrapper for <code class="inline">gcd()</code> that determines whether two numbers are prime:</p>

<div class="highlight"><pre><code class="language-python block" data-lang="python"><span class="k">def</span> <span class="nf">coprime</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span></code></pre></div>

<a data-scroll="" href="#toc-container"><h2 id="tocAnchor-1-4-4">finding modular inverses</h2></a>
<p>Given a value <script type="math/tex">a</script> and modulus <script type="math/tex">c</script>, the modular multiplicative inverse of <script type="math/tex">a</script> is a value <script type="math/tex">b</script> that satisfies:</p>

<script type="math/tex; mode=display">ab \equiv 1 \pmod c</script>

<p>This implies that there exists some value <script type="math/tex">d</script> for which:</p>

<script type="math/tex; mode=display">ab = 1 + cd\\
ab - cd = 1</script>

<p>This turns out to be in the form of <a href="https://en.wikipedia.org/wiki/B%C3%A9zout's_identity">Bézout’s identity</a>, which
states that for values <script type="math/tex">m</script> and <script type="math/tex">n</script>, there exist values <script type="math/tex">x</script> and <script type="math/tex">y</script> that satisfy:</p>

<script type="math/tex; mode=display">mx + ny = \gcd(m, n)</script>

<p><script type="math/tex">x</script> and <script type="math/tex">y</script>, called Bézout coefficients, can be solved for using the <a href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm">Extended Euclidean
algorithm</a> (EEA). <script type="math/tex">x</script> corresponds to <script type="math/tex">b</script>, or the
modular inverse that we were looking for, while <script type="math/tex">y</script> can be thrown out once computed. The EEA will also give us the
GCD of <script type="math/tex">m</script> and <script type="math/tex">n</script> – it is, after all, an extension of the Euclidean algorithm, which we use to find the GCD of
two values. We need to verify that it equals 1, since we make the assume that <script type="math/tex">\gcd(m, n) = 1</script>; if it doesn’t, <script type="math/tex">a</script>
has no modular inverse. Since <code class="inline">modular_inverse()</code> is just a wrapper for EEA – to be implemented in a function called
<code class="inline">bezout_coefficients()</code> – its definition is simple:</p>

<div class="highlight"><pre><code class="language-python block" data-lang="python"><span class="k">def</span> <span class="nf">modular_inverse</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">modulus</span><span class="p">):</span>
    <span class="n">coef1</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">gcd</span> <span class="o">=</span> <span class="n">bezout_coefficients</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">modulus</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">coef1</span> <span class="k">if</span> <span class="n">gcd</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="bp">None</span></code></pre></div>

<p><code class="inline">bezout_coefficients()</code> is a bit tricker:</p>

<div class="highlight"><pre><code class="language-python block" data-lang="python"><span class="k">def</span> <span class="nf">bezout_coefficients</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">quotient</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">coef1</span><span class="p">,</span> <span class="n">coef2</span><span class="p">,</span> <span class="n">gcd</span> <span class="o">=</span> <span class="n">bezout_coefficients</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">remainder</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coef2</span><span class="p">,</span> <span class="n">coef1</span> <span class="o">-</span> <span class="n">quotient</span> <span class="o">*</span> <span class="n">coef2</span><span class="p">,</span> <span class="n">gcd</span></code></pre></div>

<p>Let’s see why it works.</p>

<h3 id="the-extended-euclidean-algorithm">the Extended Euclidean algorithm</h3>
<p>How to solve for <script type="math/tex">x</script> and <script type="math/tex">y</script>? Bezout’s Identity states:</p>

<script type="math/tex; mode=display">\gcd(a, b) = ax + by\\</script>

<p>or, for <script type="math/tex">\gcd(b, a \imod b)</script>:</p>

<script type="math/tex; mode=display">\gcd(b, a \imod b) = bx' + (a \imod b)y'\\</script>

<p>Let’s simplify:</p>

<script type="math/tex; mode=display">a \imod b = a - \lfloor \frac{a}{b} \rfloor b</script>

<p>Here, <script type="math/tex">\lfloor \rfloor</script> represents the <em>floor</em> function, which floors the result of <script type="math/tex">\frac{a}{b}</script> to an integer.</p>

<script type="math/tex; mode=display">\gcd(b, a \imod b) = bx' + (a - \lfloor \frac{a}{b} \rfloor b)y' =\\
  bx' + ay' - \lfloor \frac{a}{b} \rfloor by' =\\
  ay' + b(x' - \lfloor \frac{a}{b} \rfloor y')</script>

<p>Since we know, by the already proven Euclidean algorithm, that <script type="math/tex">\gcd(a, b) = \gcd(b, a \imod b)</script>, we can write:</p>

<script type="math/tex; mode=display">ax + by = ay' + b(x' - \lfloor \frac{a}{b} \rfloor y')</script>

<p>So, <script type="math/tex">x = y'</script> and <script type="math/tex">y = x' - \lfloor \frac{a}{b} \rfloor y'</script>. But what are <script type="math/tex">x'</script> and <script type="math/tex">y'</script>? They’re the results of
running the EEA on <script type="math/tex">(b, a \imod b)</script>! Classic recursion. In sum:</p>

<div class="highlight"><pre><code class="language-python block" data-lang="python"><span class="k">def</span> <span class="nf">bezout_coefficients</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">quotient</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">coef1</span><span class="p">,</span> <span class="n">coef2</span> <span class="o">=</span> <span class="n">bezout_coefficients</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">remainder</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">coef2</span><span class="p">,</span> <span class="n">coef1</span> <span class="o">-</span> <span class="n">quotient</span> <span class="o">*</span> <span class="n">coef2</span></code></pre></div>

<p>Of course, we need a base case, or we’ll end up recursing <em>ad infinitum</em>. Let’s take the case of <script type="math/tex">b = 0</script>.</p>

<script type="math/tex; mode=display">ax + by = \gcd(a, b)\\
b = 0\\
ax + 0y = \gcd(a, 0)\\
ax = |a|\\
x = \frac{|a|}{a}</script>

<p>So, if <script type="math/tex">b = 0</script>, we set the <script type="math/tex">x</script> coefficient to 1 if <script type="math/tex">a</script> is positive and -1 is <script type="math/tex">a</script> is negative, and set <script type="math/tex">y</script>
to… what? If <script type="math/tex">b</script> is 0, then <script type="math/tex">y</script> can take on any value. For simplicity’s sake we’ll choose 0. Our revised
definition looks like:</p>

<div class="highlight"><pre><code class="language-python block" data-lang="python"><span class="k">def</span> <span class="nf">bezout_coefficients</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">quotient</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">coef1</span><span class="p">,</span> <span class="n">coef2</span> <span class="o">=</span> <span class="n">bezout_coefficients</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">remainder</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coef2</span><span class="p">,</span> <span class="n">coef1</span> <span class="o">-</span> <span class="n">quotient</span> <span class="o">*</span> <span class="n">coef2</span></code></pre></div>

<p>Also note that, since this is simply a more involved version of the Euclidean algorithm (we’re making recursive calls
to <code class="inline">bezout_coefficients(b, remainder)</code> and have a base case of <code class="inline">b == 0</code>), when we hit the base case, <code class="inline">abs(a)</code> is the
GCD of <code class="inline">a</code> and <code class="inline">b</code>. Since <code class="inline">modular_inverse()</code> needs to check that the GCD of its two arguments equals 1, we should
return it in addition to the coefficients themselves. Hence, we’ll let it trickle up from our base case into the final
return value:</p>

<div class="highlight"><pre><code class="language-python block" data-lang="python"><span class="k">def</span> <span class="nf">bezout_coefficients</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">quotient</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">coef1</span><span class="p">,</span> <span class="n">coef2</span><span class="p">,</span> <span class="n">gcd</span> <span class="o">=</span> <span class="n">bezout_coefficients</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">remainder</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coef2</span><span class="p">,</span> <span class="n">coef1</span> <span class="o">-</span> <span class="n">quotient</span> <span class="o">*</span> <span class="n">coef2</span><span class="p">,</span> <span class="n">gcd</span></code></pre></div>

<a data-scroll="" href="#toc-container"><h2 id="tocAnchor-1-4-5">generating large, random primes</h2></a>
<p>Here’s the idea:</p>

<ol>
  <li>generate a large, random, <strong>odd</strong> number <script type="math/tex">x</script>
</li>
  <li>check <script type="math/tex">x</script> for primality
    <ol>
      <li>if <script type="math/tex">x</script> prime, return it</li>
      <li>otherwise, increment <script type="math/tex">x</script> by 2, and return to step <strong>2.)</strong>
</li>
    </ol>
  </li>
</ol>

<p>Easy enough, except for the bit about testing primality. How to do so efficiently? We’ll turn to the
<a href="https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test">Rabin-Miller</a> algorithm, a probabilistic primality
test which either tells us with absolute certainty that a number is composite, or with high likelihood that it’s prime.
We’re fine with a merely probabilistic solution because it’s <em>fast</em>, since speed is a non-negligible issue due to the
size of the numbers that we’re dealing with, and also because the chances of a false positive (ie indicating that a
number is prime when it’s actually composite) are astronomically low after even only a few iterations of the test.</p>

<h3 id="rabin-miller-primality-test">Rabin-Miller primality test</h3>
<p>The Rabin-Miller test relies on the below two assumptions (just accept that they’re true for now, and we’ll prove them
later on). If <script type="math/tex">p</script> is a prime number:</p>

<ol>
  <li>
<script type="math/tex">a ^ {p - 1} \equiv 1 \pmod p</script> for any <script type="math/tex">a</script> not divisible by <script type="math/tex">p</script>
</li>
  <li>for any <script type="math/tex">x</script> that satisfies <script type="math/tex">x ^ 2 \equiv 1 \pmod p</script>, <script type="math/tex">x</script> <strong>must</strong> equal ±1</li>
</ol>

<p>Using these, you can test a value <script type="math/tex">n</script> for compositeness like so (note that we return <code class="inline">true</code>/<code class="inline">false</code> to indicate
definite compositeness/probable primality respectively):</p>

<ol>
  <li>pick a random value <script type="math/tex">a</script> in the range <script type="math/tex">[2, n - 1]</script>
</li>
  <li>use <strong>assumption 1</strong> to assert that <script type="math/tex">a ^ {n - 1} \equiv 1 \pmod n</script>); if it’s not, return <code class="inline">true</code>
</li>
  <li>if <script type="math/tex">a</script> has an integer square root, let <script type="math/tex">a' = \sqrt a</script>; otherwise, return <code class="inline">false</code>
</li>
  <li>since <script type="math/tex">a' ^ 2 \equiv 1 \pmod n</script>, we can use <strong>assumption 2</strong> to assert that <script type="math/tex">a' \equiv \pm 1 \pmod n</script>; if not,
return <code class="inline">true</code>
</li>
  <li>otherwise, repeat steps 3-4, taking the square root of <script type="math/tex">a'</script>, and the square root of that, and so on, until you
hit a value that doesn’t have an integer square root.</li>
  <li>if you haven’t already returned anything, you’ve satisfied assumptions <strong>1</strong> and <strong>2</strong> for all testable cases and
can return <code class="inline">false</code>.</li>
</ol>

<p>In sum, we return <code class="inline">true</code> if we’ve confirmed that <script type="math/tex">a</script> is a <em>witness to the compositeness</em> of <script type="math/tex">n</script>, and <code class="inline">false</code> if
<script type="math/tex">a</script> does <em>not</em> prove that <script type="math/tex">n</script> is composite – transitively, there is a high chance that <script type="math/tex">n</script> is prime, but we can
only be more sure by running more such tests. While the above steps serve as a good verbal description of the
algorithm, we’ll have to slightly modify them to convert the algorithm into real code.</p>

<p>We need to implement a function <code class="inline">is_witness()</code>, which checks whether a random value is a witness to the compositeness
of our prime candidate, <script type="math/tex">n</script>.</p>

<ol>
  <li>write <script type="math/tex">n - 1</script> in the form <script type="math/tex">2 ^ s d</script>. <script type="math/tex">n=73</script>, for instance, would yield <script type="math/tex">s=3</script> and <script type="math/tex">d=9</script>, since <script type="math/tex">73 - 1 =
72 = 2 ^ 3 \cdot 9</script>.</li>
  <li>pick a random value <script type="math/tex">a</script> in the range <script type="math/tex">[2, n - 1]</script>. We’ll check whether this is a witness for <script type="math/tex">n</script>.</li>
  <li>let <script type="math/tex">x = a ^ d \imod n</script>
</li>
  <li>if <script type="math/tex">x \equiv \pm 1 \pmod n</script>, then return <code class="inline">false</code>
</li>
  <li>repeat <script type="math/tex">s - 1</script> times:
    <ol>
      <li>let <script type="math/tex">x = x ^ 2 \imod n</script>
</li>
      <li>if <script type="math/tex">x = 1</script>, return <code class="inline">true</code>
</li>
      <li>if <script type="math/tex">x = n - 1</script>, return <code class="inline">false</code>
</li>
    </ol>
  </li>
  <li>if we haven’t returned yet, return <code class="inline">true</code>
</li>
</ol>

<p>These steps seem quite a bit different from before, but in reality, they’re exactly the same and just operating in
reverse. We start with a value that doesn’t have an integer square root, and square it until we hit <script type="math/tex">a ^ {n - 1}</script>.
Why did we bother decomposing <script type="math/tex">n - 1</script> into the form of <script type="math/tex">2 ^ s d</script>? Well, it allows us to rewrite <script type="math/tex">a ^ {n - 1}</script>
as <script type="math/tex">a ^ {2 ^ s d}</script>, and now we know <strong>exactly</strong> how many times we can take square roots before we hit a value that
isn’t reducible any further – in this case, <script type="math/tex">a ^ d</script>.</p>

<script type="math/tex; mode=display">a_1 = \sqrt{a ^ {2 ^ s d}} = (a ^ {2 ^ s d}) ^ \frac{1}{2} = a ^ {\frac{1}{2} \cdot 2 \cdot 2 ^ {s - 1} d} =
  a ^ {2 ^ {s - 1} d}\\
a_2 = \sqrt{a ^ {2 ^ {s - 1} d}} = (a ^ {2 ^ {s - 1} d}) ^ \frac{1}{2} = a ^ {\frac{1}{2} \cdot 2 \cdot 2 ^ {s - 2} d}
  = a ^ {2 ^ {s - 2} d}\\
\ldots\\
a_{last} = a ^ d</script>

<p>So, if we start with <script type="math/tex">a ^ d</script> and square it, we’ll get <script type="math/tex">a ^ {2d}</script>, then <script type="math/tex">a ^ {2 ^ 2 d}</script>, then <script type="math/tex">a ^ {2 ^ 3 d}</script>,
and ultimately <script type="math/tex">a ^ {2 ^ s d}</script>, or <script type="math/tex">a ^ {n - 1}</script>. What’s the advantage of starting from the non-reducible value and
squaring it, rather than the reducible value and taking its square roots? It sometimes allows us to short-circuit the
process. For instance, as we iterate through the squares of <script type="math/tex">a ^ d</script>, if we find an occurrence of -1, we know that
we’ll get 1 when we square it, and 1 when we square that, and keep on getting 1s until we stop iterating. As a
consequence, we know that we won’t find any failing conditions, and can exit early by returning <code class="inline">false</code> (<strong>step 5.3</strong>).
The same goes for <strong>step 4</strong>: if <script type="math/tex">a ^ d \equiv \pm 1 \pmod n</script>, we know that each of the following squares will equal
1, so we immediately return <code class="inline">false</code>.</p>

<p>The failing conditions – ie those that cause the algorithm to return <code class="inline">true</code> – might not be immediately clear. In
<strong>5.2</strong>, we know that, if <script type="math/tex">x = 1</script>, we’ve violated <strong>assumption 2</strong>, because that implies that the previous value of
<script type="math/tex">x</script> was not equivalent to <script type="math/tex">\pm 1 \pmod n</script>. Wait, why? Because if it were equal to -1, we would’ve already returned
via <strong>5.3</strong> in the previous iteration, and if it were <script type="math/tex">1</script>, then we would’ve returned either from <strong>5.3</strong> in an
earlier iteration still or <strong>4</strong> at the very beginning. We also return <code class="inline">true</code> when we hit <strong>6</strong>, because we know that
by that point, if <strong>assumption 1</strong> is:</p>

<ol>
  <li>true, and <script type="math/tex">x = a ^ {n - 1} \equiv 1 \pmod n</script>, then the previous value of <script type="math/tex">x</script> can’t be either 1 or -1 because
we would already have returned via either <strong>4</strong> or <strong>5.3</strong>.</li>
  <li>false, then by definition <script type="math/tex">n</script> can’t be prime, since the assumption <em>must</em> hold true for prime <script type="math/tex">n</script>
</li>
</ol>

<p>Finally, we simply repeat the <code class="inline">is_witness()</code> test <script type="math/tex">k = 5</script> times. Here’s the final implementation:</p>

<div class="highlight"><pre><code class="language-python block" data-lang="python"><span class="k">def</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="n">s</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">decompose_to_factors_of_2</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_witness</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">modular_power</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">modular_power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>

            <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>

        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_witness</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="k">return</span> <span class="bp">True</span>

<span class="k">def</span> <span class="nf">decompose_to_factors_of_2</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">num</span>

    <span class="k">while</span> <span class="n">d</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">//=</span> <span class="mi">2</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span></code></pre></div>

<p>Note that we’ve introduced a currently undefined function, <code class="inline">modular_power()</code>. The problem with computing <script type="math/tex">a ^ d \imod
n</script> and <script type="math/tex">x ^ 2 \imod n</script> is that <script type="math/tex">a</script>, <script type="math/tex">d</script>, <script type="math/tex">x</script>, and <script type="math/tex">n</script> are <strong>HUGE</strong>. Simply running <code class="inline">(a ** d) % n</code> would be
asking for trouble. Fortunately, there are efficient ways of performing modular exponentiation, and we’ll implement
one such method in the <code class="inline">modular_power()</code> function later in this article. Now, we need to actually prove the two
assumptions that we base Rabin-Miller on.</p>

<h4 id="euclids-lemma">Euclid’s lemma</h4>
<p>…but before we do so, we need to prove <a href="https://en.wikipedia.org/wiki/Euclid's_lemma">Euclid’s Lemma</a>, since both of
the following proofs depend on it. It states that if <script type="math/tex">p</script> is relatively prime to <script type="math/tex">a</script> and <script type="math/tex">p \divs ab</script>, then <script type="math/tex">p
\divs b</script>. We’ll prove it using Bezout’s Identity. The GCD of <script type="math/tex">a</script> and <script type="math/tex">p</script> is 1, so there must exist <script type="math/tex">x</script> and <script type="math/tex">y</script>
that satisfy:</p>

<script type="math/tex; mode=display">ax + py = 1</script>

<p>Multiply both sides by <script type="math/tex">b</script>:</p>

<script type="math/tex; mode=display">abx + pby = b</script>

<p><script type="math/tex">abx</script> is divisible by <script type="math/tex">p</script> (because it’s divisible by <script type="math/tex">ab</script>, which is divisible by <script type="math/tex">p</script> according to the lemma’s
requisite), and <script type="math/tex">pby</script> is by definition divisible by <script type="math/tex">p</script>, so <script type="math/tex">b</script> must be divisible by <script type="math/tex">p</script> too.</p>

<h4 id="proof-of-assumption-1">proof of assumption 1</h4>
<p>Our first assumption was that for a prime <script type="math/tex">p</script>, <script type="math/tex">a ^ {p - 1} \equiv 1 \pmod p</script> for any <script type="math/tex">a</script> <strong>not divisible by
<script type="math/tex">p</script></strong>. This is better known as <a href="https://en.wikipedia.org/wiki/Fermat's_little_theorem">Fermat’s Little Theorem</a>. To
prove it, begin by multiplying all of the numbers in the range <script type="math/tex">[1, p)</script> by <script type="math/tex">a</script>:</p>

<script type="math/tex; mode=display">a, 2a, 3a, \ldots, (p - 1) a</script>

<p>We make two observations:</p>

<ol>
  <li>
    <p>given two values <script type="math/tex">x</script> and <script type="math/tex">y</script>, <script type="math/tex">ax \equiv ay \pmod p</script> is equivalent to <script type="math/tex">x \equiv y \pmod p</script> (we effectively
divide out <script type="math/tex">a</script>). We can prove this by rewriting <script type="math/tex">ax \equiv ay \pmod p</script> as <script type="math/tex">ax - ay \equiv 0 \pmod p</script>, which
implies that <script type="math/tex">p \divs ax - ay</script>, or <script type="math/tex">p \divs a(x - y)</script>. By Euclid’s Lemma, since <script type="math/tex">p</script> and <script type="math/tex">a</script> are coprime
(reminder: this is a criterion of Fermat’s Little Theorem), <script type="math/tex">p \divs x - y</script>, which means we can write <script type="math/tex">x - y
\equiv 0 \pmod p</script>, or <script type="math/tex">x \equiv y \pmod p</script>.</p>
  </li>
  <li>
    <p>when each of its elements is simplified in <script type="math/tex">\imod p</script>, the above sequence is simply a rearrangement of <script type="math/tex">1, 2,
\ldots, p - 1</script>. This is true because, firstly, its values all lie in the range <script type="math/tex">[1, p)</script> – none can equal 0
since <script type="math/tex">p</script> shares no factors other than 1 with either <script type="math/tex">a</script> or any value in <script type="math/tex">1, 2, \ldots, p - 1</script> due to its
primeness. The trick now is to realize that, if we have two distinct values <script type="math/tex">x</script> and <script type="math/tex">y</script>, and know that <script type="math/tex">ax
\equiv ay \pmod p</script>, then by the previous observation we can “divide out <script type="math/tex">a</script>” and have <script type="math/tex">x \equiv y \pmod p</script>.
If <script type="math/tex">x</script> and <script type="math/tex">y</script> were two values chosen from the <script type="math/tex">1, \ldots, p - 1</script> sequence, we’d know that they’re all less
than <script type="math/tex">p</script>, and can thus remove the <script type="math/tex">\imod p</script> from the expression, leaving us with: <script type="math/tex">x = y</script>. In conclusion,
the only way to satisfy <script type="math/tex">ax \equiv ay \imod p</script> is to have <script type="math/tex">x</script> be the same item as <script type="math/tex">y</script>, and that means that
the distinct values in <script type="math/tex">a, \ldots, (p - 1) a</script> map to distinct values in <script type="math/tex">1, \ldots, p - 1</script>.</p>
  </li>
</ol>

<p>By <strong>observation 1</strong>:</p>

<script type="math/tex; mode=display">a \cdot 2a \cdot \ldots \cdot (p - 1) a \equiv 1 \cdot 2 \cdot \ldots \cdot (p - 1) \pmod p\\
a ^ {p - 1} (p - 1)! \equiv (p - 1)! \pmod p</script>

<p>By <strong>observation 2</strong>, we can cancel out each of the factors of <script type="math/tex">(p - 1)!</script> from both sides of the expressions (after
all, <script type="math/tex">p</script> is prime and all of the factors of <script type="math/tex">(p - 1)!</script> are less than it, so it’s coprime with all of them), which
leaves us with:</p>

<script type="math/tex; mode=display">a ^ {p - 1} \equiv 1 \pmod p</script>

<p>QED.</p>

<h4 id="proof-of-assumption-2">proof of assumption 2</h4>
<p>We now prove assumption 2: if <script type="math/tex">p</script> is prime and <script type="math/tex">x ^ 2 \equiv 1 \pmod p</script>, <script type="math/tex">x</script> must equal <script type="math/tex">\pm 1 \imod p</script>. First,
for greater clarity later on, we can rewrite our conclusion as: <script type="math/tex">p</script> must divide either <script type="math/tex">x - 1</script> or <script type="math/tex">x + 1</script>. Now,
if <script type="math/tex">x ^ 2 \equiv 1 \pmod p</script>, then:</p>

<script type="math/tex; mode=display">x ^ 2 - 1 \equiv 0 \pmod p\\
p \divs x ^ 2 - 1\\
p \divs (x - 1)(x + 1)</script>

<p>If <script type="math/tex">p</script> divides <script type="math/tex">x - 1</script>, then:</p>

<script type="math/tex; mode=display">x - 1 \equiv 0 \pmod p\\
x \equiv 1 \pmod p</script>

<p>and we’ve proven our conclusion. What if <script type="math/tex">p</script> <em>doesn’t</em> divide <script type="math/tex">x - 1</script>? We can then leverage Euclid’s Lemma: if
<script type="math/tex">p</script> is relatively prime to <script type="math/tex">a</script> and <script type="math/tex">p \divs ab</script>, then <script type="math/tex">p \divs b</script>. We know that <script type="math/tex">p</script> is prime and doesn’t
divide <script type="math/tex">x - 1</script>, so it’s relatively prime to <script type="math/tex">x - 1</script>, and we know that it divides <script type="math/tex">(x - 1)(x + 1)</script>. As a result,
it has to divide <script type="math/tex">x + 1</script>, which implies that: <script type="math/tex">x \equiv -1 \pmod p</script>. Again, we’ve proven our conclusion, and thus
proven assumption 2.</p>

<h3 id="applying-rabin-miller">applying Rabin-Miller</h3>
<p>Now that we’ve implemented Rabin-Miller, creating a large, random prime is almost trivial:</p>

<div class="highlight"><pre><code class="language-python block" data-lang="python"><span class="k">def</span> <span class="nf">get_random_prime</span><span class="p">(</span><span class="n">num_bits</span><span class="p">):</span>
    <span class="n">lower_bound</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">num_bits</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">upper_bound</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">num_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">guess</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">guess</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">guess</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="ow">not</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">guess</span><span class="p">):</span>
        <span class="n">guess</span> <span class="o">+=</span> <span class="mi">2</span>

    <span class="k">return</span> <span class="n">guess</span></code></pre></div>

<p>The <code class="inline">num_bits</code> parameter is a bit of a weird way of specifying the desired size of the prime, but it’ll make sense
since we usually want to create RSA keys of a specific bit-length (more on this later on).</p>

<a data-scroll="" href="#toc-container"><h2 id="tocAnchor-1-4-6">wrapping it all up</h2></a>
<p>At long last, we can define our <code class="inline">create_key_pair()</code> function.</p>

<div class="highlight"><pre><code class="language-python block" data-lang="python"><span class="k">def</span> <span class="nf">create_key_pair</span><span class="p">(</span><span class="n">bit_length</span><span class="p">):</span>
    <span class="n">prime_bit_length</span> <span class="o">=</span> <span class="n">bit_length</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">get_random_prime</span><span class="p">(</span><span class="n">prime_bit_length</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">get_random_prime</span><span class="p">(</span><span class="n">prime_bit_length</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">q</span>
    <span class="n">totient</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">e_candidate</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">totient</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">e_candidate</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">e_candidate</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">coprime</span><span class="p">(</span><span class="n">e_candidate</span><span class="p">,</span> <span class="n">totient</span><span class="p">):</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">e_candidate</span>
            <span class="k">break</span>

    <span class="n">d</span> <span class="o">=</span> <span class="n">modular_inverse</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">totient</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">e</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span></code></pre></div>

<p>The only thing that requires explanation is this <code class="inline">bit_length</code> business. The idea here is that we generally want to
create RSA keys of a certain bit-length (1024 and 2048 are common values), so we pass in a parameter specifying the
length. To make sure that <script type="math/tex">n</script> has a bit-length approximately equal to <code class="inline">bit_length</code>, we need to make sure that the
primes <script type="math/tex">p</script> and <script type="math/tex">q</script> that we use to create it have a bit length of <code class="inline">bit_length / 2</code>, since multiplying two <script type="math/tex">n</script>-bit
numbers yields an approximately <script type="math/tex">2n</script>-bit value. How come? The number of bits in a positive integer <script type="math/tex">n</script> is
<script type="math/tex">\lfloor \log_2 n \rfloor + 1</script>, so the number of bits in <script type="math/tex">n ^ 2</script> is <script type="math/tex">\lfloor \log_2 n ^ 2\rfloor + 1</script>. According
to the <a href="http://www.rapidtables.com/math/algebra/logarithm/Logarithm_Rules.htm#power%20rule">logarithm power rule</a>, we can
rewrite <script type="math/tex">\log{a ^ b}</script> as <script type="math/tex">b \cdot \log a</script>, so the bit length equals <script type="math/tex">\lfloor 2\log_2 n \rfloor + 1</script>. In other
words, <script type="math/tex">n ^ 2</script> has roughly twice as many bits as <script type="math/tex">n</script>.</p>

<a data-scroll="" href="#toc-container"><h1 id="tocAnchor-1-11">encrypt/decrypt messages</h1></a>
<p>In comparison to generating keys, encrypting and decrypting data with them is mercifully simple.</p>

<ol>
  <li>encrypt a message <script type="math/tex">m</script> with public key <script type="math/tex">e</script> and modulus <script type="math/tex">n</script>: <script type="math/tex">m ^ e \imod n</script>
</li>
  <li>decrypt a message <script type="math/tex">c</script> with private key <script type="math/tex">d</script> and modulus <script type="math/tex">n</script>: <script type="math/tex">c ^ d \imod n</script>
</li>
</ol>

<div class="highlight"><pre><code class="language-python block" data-lang="python"><span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">modular_power</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">decrypt</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">modular_power</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span></code></pre></div>

<p>So, what’s <code class="inline">modular_power()</code>? The problem with the encryption and decryption operations, which look
deceptively trivial, is that all of the values involved are big. Really, really big. As a result, naively solving <script type="math/tex">a ^
b \imod c</script> by simply resolving <script type="math/tex">a ^ b</script> and then simplifying that modulo <script type="math/tex">c</script> is a no-go. Fortunately, there are
more efficient ways of performing <a href="https://en.wikipedia.org/wiki/Modular_exponentiation">modular exponentiation</a>, like
exponentiation by squaring.</p>

<a data-scroll="" href="#toc-container"><h2 id="tocAnchor-1-11-1">exponentiation by squaring</h2></a>
<p>When trying to solve <script type="math/tex">a ^ b \imod c</script>, begin by representing <script type="math/tex">b</script> in binary form:</p>

<script type="math/tex; mode=display">b = 2 ^ {n - 1} bit_{n - 1} + 2 ^ {n - 2} bit_{n - 2} + \ldots + 2 bit_1 + bit_0</script>

<p>where <script type="math/tex">n</script> is the total number of bits in <script type="math/tex">b</script>, and <script type="math/tex">bit</script> represents the value of each bit – either 0 or 1. Now,
rewrite the original expression:</p>

<script type="math/tex; mode=display">a ^ b \imod c =\\
a ^ {2 ^ {n - 1} bit_{n - 1} + 2 ^ {n - 2} bit_{n - 2} + \ldots + 2 bit_1 + bit_0} \imod c =\\
a ^ {2 ^ {n - 1} bit_{n - 1}} \cdot a ^ { 2 ^ {n - 2} bit_{n - 2}} \cdot \ldots \cdot a ^ {2 bit_1} \cdot a ^ {bit_0}
  \imod c\\</script>

<p>For illustrative purposes, let’s temporarily remove the <script type="math/tex">bit</script> factor from each exponent, which leaves us with:</p>

<script type="math/tex; mode=display">a ^ {2 ^ {n - 1}} \cdot a ^ { 2 ^ {n - 2}} \cdot \ldots \cdot a ^ {2} \cdot a \imod c</script>

<p>It’s now obvious that each factor is a square of the one that precedes it: <script type="math/tex">a ^ {2}</script> is the square of <script type="math/tex">a</script>,
<script type="math/tex">a ^ {2 ^ {n - 1}}</script> is the square of <script type="math/tex">a ^ { 2 ^ {n - 2}}</script>, etc. If we were to programmatically solve the
expression, we could maintain a variable, say <code class="inline">accumulator</code>, that we’d initialize to <script type="math/tex">a</script>, and square from
factor to factor to avoid recomputing <script type="math/tex">a ^ {\text{big exponent}}</script> every time. Now, let’s reintroduce <script type="math/tex">bit</script>:</p>

<script type="math/tex; mode=display">a ^ {2 ^ {n - 1} bit_{n - 1}} \cdot a ^ { 2 ^ {n - 2} bit_{n - 2}} \cdot \ldots \cdot a ^ {2 bit_1} \cdot a ^ {bit_0}
  \imod c\\</script>

<p>The good thing is that <script type="math/tex">bit</script> has a limited set of possible values: just 0 and 1! Any value in the form
<script type="math/tex">a ^ {2 ^ p bit}</script> – that is, all of the above factors – evaluates to <script type="math/tex">a ^ {2 ^ p}</script> when <script type="math/tex">bit = 1</script>,
and <script type="math/tex">a ^ 0</script>, or 1, when <script type="math/tex">bit = 0</script>. In other words, the value of <script type="math/tex">bit</script> only controls whether or not we multiply
one of the factors into the accumulator that’ll become our ultimate result (since if <script type="math/tex">bit = 0</script>, we’ll just end up
multiplying in 1, which means we shouldn’t even bother). Thus, <code class="inline">modular_power()</code> might look something like this:</p>

<div class="highlight"><pre><code class="language-python block" data-lang="python"><span class="k">def</span> <span class="nf">modular_power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">modulus</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="n">exp</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">exp</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">*</span> <span class="n">base</span>
        <span class="n">exp</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">base</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="k">return</span> <span class="n">result</span> <span class="o">%</span> <span class="n">modulus</span></code></pre></div>

<p>But we still haven’t addressed the issue of multiplying huge numbers by huge numbers, and this version of
<code class="inline">modular_power()</code> doesn’t perform much better than <code class="inline">(base ** exp) % modulus</code> (in fact, after some spot checking, it
appears to be much slower!). We can address that by taking advantage of the following property of modular
multiplication:</p>

<script type="math/tex; mode=display">xy \imod z = (x \imod z)(y \imod z) \imod z</script>

<p>We can prove it by rewriting <script type="math/tex">x</script> and <script type="math/tex">y</script> in terms of <script type="math/tex">z</script>:</p>

<script type="math/tex; mode=display">x = q_x z + r_x\\
y = q_y z + r_y</script>

<p>and substituting that into the original expression:</p>

<script type="math/tex; mode=display">xy \imod z =\\
(q_x z + r_x) (q_y z + r_y) \imod z =\\
q_x q_y z ^ 2 + q_x z r_y + r_x q_y z + r_x r_y \imod z =\\
z(q_x q_y z + q_x r_y + r_x q_y) + r_x r_y \imod z =\\
r_x r_y \imod z</script>

<p>We’re able to remove the entire chunk of the expression that gets multiplied by <script type="math/tex">z</script> because it’s by definition
divisible by <script type="math/tex">z</script>, meaning that, taken <script type="math/tex">\imod z</script>, it would equal 0, and wouldn’t contribute anything to the sum.
Thus, <script type="math/tex">xy \imod z</script> equals <script type="math/tex">r_x r_y \imod z</script>, or <script type="math/tex">(x \imod z)(y \imod z) \imod z</script>.</p>

<p>Using that, we can make the following adjustment to our initial implementation:</p>

<div class="highlight"><pre><code class="language-python block" data-lang="python"><span class="k">def</span> <span class="nf">modular_power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">modulus</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">base</span> <span class="o">%=</span> <span class="n">modulus</span>

    <span class="k">while</span> <span class="n">exp</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">exp</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span> <span class="o">*</span> <span class="n">base</span><span class="p">)</span> <span class="o">%</span> <span class="n">modulus</span>
        <span class="n">exp</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
        <span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="n">base</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">modulus</span>

    <span class="k">return</span> <span class="n">result</span></code></pre></div>

<p>We’re now taking <code class="inline">% modulus</code> in a bunch of places, which is valid due to the above property and prevents the value of
both <code class="inline">result</code> and <code class="inline">base</code> from growing out of control.</p>

<p>That tops off our implementation of RSA. <a href="http://files.sevko.io/rsa/rsa.py">Here’s</a> the entire source file.</p>

<a data-scroll="" href="#toc-container"><h1 id="tocAnchor-1-13">acknowledgements</h1></a>
<p>I wouldn’t have been able to present most of the proofs in this article without help from the following sources. One of
the key motivations for gathering them all in one post is that, as I tried to understand all of the moving parts of
RSA, I needed to sift through <em>a lot</em> of material to find accessible and satisfactory explanations:</p>

<ul>
  <li><a href="https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/the-euclidean-algorithm">the Euclidean algorithm</a></li>
  <li><a href="http://pages.pacificcoast.net/~cazelais/222/xeuclid.pdf">the Extended Euclidean algorithm</a></li>
  <li><a href="https://en.wikipedia.org/?title=Proofs_of_Fermat%27s_little_theorem">Fermat’s Little Theorem</a></li>
  <li><a href="http://home.sandiego.edu/~dhoffoss/teaching/cryptography/10-Rabin-Miller.pdf">Rabin-Miller test</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Modular_exponentiation#Right-to-left_binary_method">exponentiation by squaring</a></li>
</ul>

	
</div>

<section id="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript" src="http://sevko.disqus.com/embed.js"></script>
	<noscript><b id="comments-noscript">Enable JavaScript to see comments.</b></noscript>
</section>


	<script src="/js/smooth-scroll/dist/js/bind-polyfill.min.js"></script>
<script src="/js/smooth-scroll/dist/js/smooth-scroll.min.js"></script>
<script>
	smoothScroll.init({offset: 30});
</script>



		</div>

	</body>
</html>
