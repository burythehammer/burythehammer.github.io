<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:content="http://purl.org/rss/1.0/modules/content/">
	<channel>
		<title>Severyn Kozak</title>
		<description>
			
				Severyn Kozak&#39;s personal portfolio site and blog.
			
		</description>
		<link>http://sevko.io</link>
		<atom:link href="http://sevko.io/articles/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>emulating exceptions in C</title>
				
					<category>c></category>
				
					<category>parsing></category>
				
					<category>algorithms></category>
				
				<description>case study: a recursive-descent parser
I recently stumbled across a practical use-case for simulated exceptions in C while writing a recursive-descent JSON
parser for fun and profit. In this quick write-up, I’ll give a high-level overview of the problems that I ran into, why
exceptions were ideal for error handling, and how I emulated them in C.

</description>
				<image>
					<url>http://www.w3schools.com/images/logo.gif</url>
					<title>A key.</title>
					<link>http://files.sevko.io/img/thumbnails/exceptions_in_c.png</link>
				</image>
				<content type="html">
					
					<h1 id="case-study-a-recursive-descent-parser">case study: a recursive-descent parser</h1>
<p>I recently stumbled across a practical use-case for simulated exceptions in C while writing a recursive-descent JSON
parser for fun and profit. In this quick write-up, I’ll give a high-level overview of the problems that I ran into, why
exceptions were ideal for error handling, and how I emulated them in C.</p>

<h2 id="recursive-descent-parsing">recursive-descent parsing</h2>
<p>I won’t dwell on the details of the parser itself because this post is about the error-handling mechanism, but a
minimal understanding of recursive-descent parsing is necessary to appreciate it. As with any kind of parsing, we start
out with the <a href="https://en.wikipedia.org/wiki/Formal_grammar">formal grammar</a> of our language/data format/whatever. A
simple grammar for common programming language literals might look like:</p>

<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="ss">value</span><span class="p">:</span> <span class="n">string</span> <span class="o">|</span> <span class="n">number</span> <span class="o">|</span> <span class="n">boolean</span>
<span class="ss">string</span><span class="p">:</span> <span class="s1">&#39;&quot;&#39;</span> <span class="n">char</span><span class="o">*</span> <span class="s1">&#39;&quot;&#39;</span>
<span class="ss">boolean</span><span class="p">:</span> <span class="s1">&#39;true&#39;</span> <span class="o">|</span> <span class="s1">&#39;false&#39;</span>
<span class="ss">number</span><span class="p">:</span> <span class="s1">&#39;-&#39;</span><span class="p">?</span> <span class="n">digit</span><span class="o">+</span> <span class="p">(</span><span class="s1">&#39;.&#39;</span> <span class="n">digit</span><span class="o">+</span><span class="p">)?</span>
<span class="ss">array</span><span class="p">:</span> <span class="s1">&#39;[&#39;</span> <span class="n">value</span> <span class="s1">&#39;]&#39;</span></code></pre></div>

<p>In fact, the <a href="http://json.org/">JSON grammar</a> that I used is fairly similar. Writing a <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">recursive-descent
parser</a> for a grammar like the above is straightforward,
because you simply map each rule onto a corresponding parse function. In pseudocode, we might have:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">parse</span><span class="p">()</span>
    <span class="c"># perform setup</span>
    <span class="k">return</span> <span class="n">parseValue</span><span class="p">()</span>

<span class="n">parseValue</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">nextIsString</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">parseString</span><span class="p">()</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">nextIsNumber</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">parseNumber</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">nextIsBoolean</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">parseBoolean</span><span class="p">()</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">nextIsArray</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">parseArray</span><span class="p">()</span>
    <span class="k">else</span>
        <span class="n">throw</span> <span class="n">ParseError</span><span class="p">()</span>

<span class="n">parseString</span><span class="p">()</span>
    <span class="n">matchChars</span><span class="p">(</span><span class="s">&#39;&quot;&#39;</span><span class="p">)</span>
    <span class="n">string</span> <span class="o">=</span> <span class="n">readCharsUntil</span><span class="p">(</span><span class="s">&#39;&quot;&#39;</span><span class="p">)</span>
    <span class="n">matchChars</span><span class="p">(</span><span class="s">&#39;&quot;&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">string</span>

<span class="n">parseBoolean</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">peekChar</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;t&#39;</span>
        <span class="n">matchChars</span><span class="p">(</span><span class="s">&#39;true&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">true</span>
    <span class="k">else</span>
        <span class="n">matchChars</span><span class="p">(</span><span class="s">&#39;false&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">false</span>

<span class="c"># and so on</span></code></pre></div>

<p>The gist is that we have a bunch of mutually recursive parsing routines that ultimately rely on very primitive,
low-level functions (like <code>nextChar()</code>, <code>readCharsUntil()</code>, <code>matchChars()</code>, etc. in the above example) that operate
directly on the string being parsed.</p>

<h1 id="error-handling">error-handling</h1>
<p>Most of the errors that we need to worry about will occur in those primitives: <code>nextChar()</code> might fail
to read a character because it hit the end of the input stream and <code>matchChars()</code> might find an unexpected character,
for example. We may also want to manually signal an error in one of our high-level parsing routines, like we do in
<code>parseValue()</code> when we can’t detect any valid values ahead. The key observations to make are that in a recursive-descent
parser, the call stack will grow quite deep, and that errors are fatal; in other words, when one occurs, we need to
<code>return</code> through many layers of function calls until we hit the <code>parse()</code> that started it all:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">getNextChar</span><span class="p">()</span>   <span class="c"># Error, hit EOF!</span>
<span class="n">matchChars</span><span class="p">()</span>
<span class="n">parseBoolean</span><span class="p">()</span>
<span class="n">parseValue</span><span class="p">()</span>
<span class="n">parseArray</span><span class="p">()</span>
<span class="n">parseValue</span><span class="p">()</span>
<span class="n">parse</span><span class="p">()</span>         <span class="c"># The top-level parse routine that we need to jump back to.</span></code></pre></div>

<p>How should we
handle errors in C, then?</p>

<h2 id="error-codes">error codes</h2>
<p>The idiomatic solution is to simply use error codes. If <code>nextChar()</code> fails, return <code>-1</code> (which is suitable because
character values can’t be negative), and make sure to actually <em>check</em> that return value every time you call it.</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">char</span> <span class="n">chr</span> <span class="o">=</span> <span class="n">nextChar</span><span class="p">(</span><span class="n">parserState</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">chr</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>Note that the <code>parserState</code> argument passed to <code>nextChar()</code> is a (pointer to a) <code>struct</code> containing the parser’s state:
a pointer to the string being parsed, its length, the current index in that string, etc.</p>

<p>In practice, we’d probably settle for a more sophisticated solution that involves storing error information inside
<code>parserState</code>, like a boolean indicating whether a failure occurred and an error message to accompany it, since it’s
more flexible:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">char</span> <span class="n">chr</span> <span class="o">=</span> <span class="n">nextChar</span><span class="p">(</span><span class="n">parserState</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">parserState</span><span class="o">-&gt;</span><span class="n">failed</span><span class="p">){</span>
    <span class="n">puts</span><span class="p">(</span><span class="n">parserState</span><span class="o">-&gt;</span><span class="n">errMsg</span><span class="p">);</span> <span class="c1">// just an example</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>Either way, the result is that we have to remember to manually check some error value after every call to a parse
routine that carried the possibility of failure. It bloats your code with repetitive conditionals and prevents you from
using the return value of a parse routine directly in an expression because, again, you need an explicit conditional.
Can we do better?</p>

<h2 id="exceptions-exceptions">exceptions, exceptions</h2>
<p>An exception mechanism would be ideal here, since we want to jump back to an arbitrary point in the call stack (in
our case, <code>parse()</code>) from any one function. While C doesn’t provide us with real exceptions, we <em>can</em> simulate
them…</p>

<h3 id="longjmp-setjmp"><code>longjmp()</code>, <code>setjmp()</code></h3>
<p>Enter <code>longjmp()</code> and <code>setjmp()</code>; like <code>goto</code>, but nuclear! From the manpage, these functions facilitate
“nonlocal jumps to a saved stack context,” or, in other words, allow you to perform jumps across functions. <strong>Use with
extreme caution.</strong> The gist is that <code>setjmp()</code> is used to initialize a <code>jmp_buf</code>, storing critical information about
the current calling environment – it’s highly system-specific, but generally includes things like the stack pointer
and current register values – and returns 0 (the <strong>first</strong> time it returns – this will be explained shortly). You can
then pass that <code>jmp_buf</code> to <code>longjmp()</code> at any other point, and the program will rewind execution back to the
<code>setjmp()</code> call. You’ll also need to pass a non-zero <code>int</code> to <code>longjmp()</code>, which will be the value that <code>setjmp()</code>
returns this time around; this allows us to discriminate between the times that <code>setjmp()</code> returns a.) initially and
b.) after a jump was performed. An example should set things straight:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;setjmp.h&gt;</span>

<span class="kt">void</span> <span class="nf">bar</span><span class="p">(</span><span class="kt">jmp_buf</span> <span class="n">jmpBuf</span><span class="p">){</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">&quot;inside bar()&quot;</span><span class="p">);</span>
    <span class="n">longjmp</span><span class="p">(</span><span class="n">jmpBuf</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">&quot;this should never run!&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">jmp_buf</span> <span class="n">jmpBuf</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">setjmp</span><span class="p">(</span><span class="n">jmpBuf</span><span class="p">)){</span>
        <span class="c1">// This runs after `setjmp()` returns normally.</span>
        <span class="n">puts</span><span class="p">(</span><span class="s">&quot;calling bar()&quot;</span><span class="p">);</span>
        <span class="n">bar</span><span class="p">(</span><span class="n">jmpBuf</span><span class="p">);</span>
        <span class="n">puts</span><span class="p">(</span><span class="s">&quot;this should never run!&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// This runs after `setjmp()` returns from a `longjmp()`.</span>
        <span class="n">puts</span><span class="p">(</span><span class="s">&quot;returned from bar()&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="n">foo</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>When compiled and run, you should see:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">calling</span> <span class="n">bar</span><span class="p">()</span>
<span class="n">inside</span> <span class="n">bar</span><span class="p">()</span>
<span class="n">returned</span> <span class="n">from</span> <span class="n">bar</span><span class="p">()</span></code></pre></div>

<p>Notice how we wrap the call to <code>setjmp()</code> in a conditional, which allows us to selectively run different code after it
returned regularly (returning 0) and then after a jump occurred (returning whatever argument was passed to <code>longjmp()</code>,
or, in our case, 1). Continuing the exceptions analogy, this is similar to a <code>try {} catch {}</code>.</p>

<p>Also, note that <code>jmp_buf</code> is <code>typedef</code>‘d as an array of the <em>actual</em> <code>jmp_buf</code> structs <strong>with only one element</strong> – in
other words, when you declare <code>jmp_buf jmpBuf;</code>, the  struct inside <code>jmpBuf</code> lives entirely on the stack but <code>jmpBuf</code>
will decay to a pointer if you pass it to a function. In my opinion that’s rather misleading and I would’ve preferred
to manually, explicitly use pointer notation when necessary, but it is what it is.</p>

<h3 id="integrating-them-into-the-parser">integrating them into the parser</h3>
<p>The idea is to initialize a <code>jmp_buf</code> in the <code>parse()</code> function with <code>setjmp()</code>, store it inside the <code>parserState</code>
struct in a <code>prevErrorTrap</code> member (couldn’t think of a better name), and then <code>longjmp()</code> to it whenever an error
occurs. If that were all, using this solution would be a no-brainer, but alas, there’s a complication: some of our
parsing routines might need to perform cleanup before exiting, like <code>free()</code>ing temporarily allocated memory. For
instance, the <code>parseArray()</code> function in my parser allocates a stretchy array to house all of the values that it
successfully parses; if an error occurs in one of the <code>parseValue()</code> calls that it makes, it needs to deallocate all of
the values parsed thus far and then the array itself.  If we jump from the point where the error occurred to the very
beginning of the parse, though, we don’t have any means of doing so.</p>

<h3 id="intermediate-cleanup">intermediate cleanup</h3>
<p>Two solutions come to mind:</p>

<ul>
  <li>storing pointers to all of the blocks of memory allocated by the parse routines inside an array in <code>parserState</code>,
and then <code>free()</code>ing them inside the top-level <code>parse()</code> if an error occurred</li>
  <li>setting intermediate jump points in functions that need to perform cleanup; in effect, catching exceptions,
cleaning up, and reraising them.</li>
</ul>

<p>I ultimately settled for the latter, and the idea’s the same as before: in functions like <code>parseArray()</code> and any
others that allocate intermediate memory, create a copy of the current jump buffer (<code>parserState-&gt;prevErrorTrap</code>),
and then set <code>parserState-&gt;prevErrorTrap</code> to a <strong>new</strong> jump buffer created with <code>setjmp()</code> – this one will get used
by all of the parse routines called by the current one. If the parse succeeds, just restore
<code>parserState-&gt;prevErrorTrap</code> to the original jump buffer before returning. If it fails, perform cleanup and jump
directly to the original buffer. Here’s an example taken straight from the parser’s source, with irrelevant bits
omitted:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">JsonArray_t</span> <span class="nf">JsonParser_parseArray</span><span class="p">(</span><span class="n">JsonParser_t</span> <span class="o">*</span><span class="n">state</span><span class="p">){</span>
    <span class="cm">/**</span>
<span class="cm">     * Omitted: perform setup here.</span>
<span class="cm">     */</span>

    <span class="kt">jmp_buf</span> <span class="n">prevErrorTrap</span><span class="p">;</span>
    <span class="n">copyJmpBuf</span><span class="p">(</span><span class="n">prevErrorTrap</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">errorTrap</span><span class="p">);</span>

    <span class="c1">// The stretchy array used to store parsed values. Read on</span>
    <span class="c1">// for why `volatile` is necessary.</span>
    <span class="n">JsonVal_t</span> <span class="o">*</span><span class="k">volatile</span> <span class="n">values</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">setjmp</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">errorTrap</span><span class="p">)){</span>

        <span class="cm">/**</span>
<span class="cm">         * Omitted: parse values into `values` with repeated calls</span>
<span class="cm">         * to `parseValue()`.</span>
<span class="cm">         */</span>

        <span class="c1">// If we get this far, then no error occurred, so restore the</span>
        <span class="c1">// original `prevErrorTrap`.</span>
        <span class="n">copyJmpBuf</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">errorTrap</span><span class="p">,</span> <span class="n">prevErrorTrap</span><span class="p">);</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">JsonArray_t</span><span class="p">){</span>
            <span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">sb_count</span><span class="p">(</span><span class="n">values</span><span class="p">),</span>
            <span class="p">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">values</span>
        <span class="p">};</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// An error occurred! Deallocate all intermediate memory,</span>
        <span class="c1">// and then jump to the previous `prevErrorTrap`.</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ind</span> <span class="o">&lt;</span> <span class="n">sb_count</span><span class="p">(</span><span class="n">values</span><span class="p">);</span> <span class="n">ind</span><span class="o">++</span><span class="p">){</span>
            <span class="n">JsonVal_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">values</span><span class="p">[</span><span class="n">ind</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">sb_free</span><span class="p">(</span><span class="n">values</span><span class="p">);</span>
        <span class="n">longjmp</span><span class="p">(</span><span class="n">prevErrorTrap</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p><code>copyJmpBuf()</code> is just a convenience wrapper for <code>memcpy()</code>:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">copyJmpBuf</span><span class="p">(</span><span class="kt">jmp_buf</span> <span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="kt">jmp_buf</span> <span class="n">src</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">memcpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">jmp_buf</span><span class="p">));</span>
<span class="p">}</span></code></pre></div>

<p>One other thing to note is that we declared the <code>values</code> pointer as <code>volatile</code> to prevent the compiler from placing it
into a register. Why? The problem is that we modify <code>values</code> after the call to <code>setjmp()</code>, namely when we
perform the initial allocation of a stretchy array and then whenever it gets resized and a <code>realloc()</code> changes the
location of the items that it contains. When a long jump occurs, register values are restored from whatever they were at the
time of the <code>setjmp()</code> call, since those are what it copied into the target <code>jmp_buf</code>; if the compiler decided to put
<code>values</code> into a register, then after the jump, it would be set to <code>NULL</code>.
To prevent that from happening, we use the <code>volatile</code> specifier. See <a href="http://stackoverflow.com/questions/7996825/why-volatile-works-for-setjmp-longjmp">this SO
post</a> for more; this is an example of
the potentially very dangerous subtleties of long jumping. In fact, while writing my parser I forgot to add in the
<code>volatile</code> specifier to <code>values</code>, and noticed that it was leaking memory (thank you <a href="http://valgrind.org/">valgrind</a>!)
whenever an error occurred even though the cleanup clause <em>was</em> getting run. It turns out that <code>values</code> would get put
into a register and then consequently take on a value of <code>NULL</code> after the jump – since that’s what it was at the time
of the original <code>setjmp()</code> – meaning that the only reference to the allocated memory was lost and it couldn’t possibly
be deallocated. Moreover, when passed to <code>free()</code>, it wouldn’t blow up, because <code>free()</code> ignores NULL pointers<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>!</p>

<p>To wrap up the above example, all of the other parsing functions that set intermediate breakpoints have virtually the same
layout, so you could even theoretically encapsulate the different statements in macros like <code>try</code> and <code>catch</code> for a
full blown mimicry of exceptions in other languages – that’s too much magic for me, though.</p>

<h1 id="in-conclusion">in conclusion</h1>
<p><code>longjmp()</code> and <code>setjmp()</code> are tricky. They’re obscure, can give rise to subtle bugs, are highly platform-specific,
and, if abused, will probably lead to awfully confusing code; a footcannon if I ever saw one. That being said, like
<code>goto</code>, they <em>do</em> have valid uses and can be very powerful when used appropriately. In this case, I think they were
superior to error codes and resulted in a slimmer, more readable implementation than what it otherwise would’ve been.
If you’re interested in more reading, I recommend <a href="http://www.di.unipi.it/~nids/docs/longjump_try_trow_catch.html">this comprehensive
article</a>. Also,
<a href="http://files.sevko.io/exceptions_in_c/json_parser_c.zip">here</a>’s the thoroughly documented parser source code; check out <code>src/json_parser.c</code>.</p>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>From <code>man -s3 free</code>: “If ptr is NULL, no operation is performed” <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>
>
				</content>
				<pubDate>Sat, 22 Aug 2015 22:00:00 +0100</pubDate>
				<link>http://sevko.io/articles/exceptions-in-c</link>
				<guid isPermaLink="true">http://sevko.io/articles/exceptions-in-c</guid>
			</item>
		
			<item>
				<title>RSA: implementation and proofs</title>
				
					<category>math></category>
				
					<category>prime numbers></category>
				
					<category>algorithms></category>
				
					<category>python></category>
				
					<category>number theory></category>
				
				<description>what is RSA?
RSA is a public-key, or asymmetric, encryption algorithm.
In contrast to symmetric algorithms, like DES and
AES, which use the same key for both encryption and
decryption, RSA employs two distinct keys: a public key used to encrypt data, and a private key used to
decrypt whatever was encrypted with the public one. The beauty of public-key encryption is that the parties involved
never need to exchange a master key, meaning that communications can be securely encrypted without any prior contact.

</description>
				<image>
					<url>http://www.w3schools.com/images/logo.gif</url>
					<title>A key.</title>
					<link>http://files.sevko.io/img/thumbnails/rsa.png</link>
				</image>
				<content type="html">
					
						<b>Warning:</b> this post contains math blocks rendered with the
						<a href="http://www.mathjax.org/">MathJax</a> JavaScript library. If you're using an RSS reader or
						otherwise have Javascript disabled, none of them will display, so you should instead read this article at
						its <a href="http://sevko.io/articles/rsa">source</a>.
					
					<h1 id="what-is-rsa">what is RSA?</h1>
<p><a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> is a <em>public-key</em>, or <em>asymmetric</em>, encryption algorithm.
In contrast to <em>symmetric</em> algorithms, like <a href="https://en.wikipedia.org/wiki/Data_Encryption_Standard">DES</a> and
<a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a>, which use the same key for both encryption and
decryption, RSA employs two distinct keys: a <strong>public</strong> key used to encrypt data, and a <strong>private key</strong> used to
decrypt whatever was encrypted with the public one. The beauty of public-key encryption is that the parties involved
never need to exchange a master key, meaning that communications can be securely encrypted without any prior contact.</p>

<p>Public-key encryption was proposed by <a href="https://en.wikipedia.org/wiki/Whitfield_Diffie">Whitfield Diffie</a> and <a href="https://en.wikipedia.org/wiki/Martin_Hellman">Martin
Hellman</a> in ‘76, while RSA itself was patented in ‘77 by <a href="https://en.wikipedia.org/wiki/Ron_Rivest">Ron
<strong>R</strong>ivest</a>, <a href="https://en.wikipedia.org/wiki/Adi_Shamir">Adi <strong>S</strong>hamir</a>, and
<a href="https://en.wikipedia.org/wiki/Leonard_Adleman">Leonard <strong>A</strong>dleman</a>, who then went on to found a
cybersecurity <a href="https://en.wikipedia.org/wiki/RSA_Security">company</a> of the same name – confusing, but great PR!</p>

<p><img src="http://files.sevko.io/rsa/rivest_shamir_adleman.png" alt="Rivest, Shamir, and Adleman" /></p>

<p><a href="https://en.wikipedia.org/wiki/Clifford_Cocks">Clifford Cocks</a>, an English cryptographer, arrived at a similar
algorithm in ‘73 while working for British intelligence at
<a href="https://en.wikipedia.org/wiki/Government_Communications_Headquarters">GHCQ</a>, but his work wasn’t declassified until
1998 due to its sensitivity. Forty years later, RSA underpins SSL certification, SSH handshakes, and lots more.</p>

<p>In this post, we’ll implement RSA, but we’ll very much take the long way around while doing so. The algorithm
introduces a number of interesting problems, like finding greatest common divisors, performing modular exponentiation,
computing modular inverses, and generating random prime numbers, each of which we’ll thoroughly explore and derive
solutions to (many of these won’t be immediately clear, so we’ll formally prove them as we go). Note that we won’t
prove RSA itself – I might add that as an extension to the article at some point in the future.</p>

<h1 id="math-precursor">math precursor</h1>
<p><script type="math/tex">\def \imod {\text{ mod }}
\def \divs {\text{ } \vert \text{ }}</script> The only thing we need to know before diving into RSA is some <a href="https://en.wikipedia.org/wiki/Modular_arithmetic">modular
arithmetic</a>, which is simply arithmetic with the property that
numbers have a maximum value (called the <em>modulus</em>) and wrap around to 0 when they exceed it. When we take a number
<script type="math/tex">a \imod b</script>, we’re basically taking the remainder of <script type="math/tex">\frac{a}{b}</script>; most programming languages provide this in the
form of a <code>mod</code> function or <code>%</code> operator. We’ll see lots of expressions in the form of:</p>

<script type="math/tex; mode=display">a \equiv b \pmod c</script>

<p>Here, the <script type="math/tex">\equiv</script> symbol implies <em>congruence</em>, or that <script type="math/tex">a \text{ mod } c</script> equals <script type="math/tex">b \text{ mod } c</script>. An
important gotcha is that <script type="math/tex">\pmod c</script> applies to <em>both</em> sides of the expression, which isn’t immediately obvious to
anyone used to the modulo operator in the programming sense. Many sources choose to omit the parentheses, simply
writing <script type="math/tex">a \equiv b \imod c</script>, which just compounds the confusion; the clearest notation would probably be something
like <script type="math/tex">(a \equiv b) \pmod c</script>. This is extremely important to remember because otherwise, expressions like <script type="math/tex">a \equiv 1
\imod b</script> won’t make any sense at all (“but if <script type="math/tex">1 \imod b</script> is equal to 1 for all <script type="math/tex">b</script> not equal to 1, why not just
write <script type="math/tex">a = 1</script>?!”).</p>

<p>Some notes about miscellaneous notation:</p>

<ol>
  <li><script type="math/tex">a \divs b</script> means that <script type="math/tex">a</script> divides, or is a factor of, <script type="math/tex">b</script></li>
  <li>range notation is used here and there: <script type="math/tex">[a, b]</script> represents all of the numbers between <script type="math/tex">a</script> and <script type="math/tex">b</script> inclusive,
<script type="math/tex">[a, b)</script> includes <script type="math/tex">a</script> but excludes <script type="math/tex">b</script>, <script type="math/tex">(a, b)</script> excludes both <script type="math/tex">a</script> <em>and</em> <script type="math/tex">b</script>, etc.</li>
</ol>

<h1 id="how-rsa-works">how RSA works</h1>
<p>RSA revolves around a numeric key-pair, or a mathematically related public and private key. The public key is made
known to the world, which can then use it to encrypt a message, while the private key can be used to decrypt anything
encrypted with the public key. Encrypting and decrypting a message is fairly straightforward, while generating a
key-pair is a more substantial process.</p>

<h1 id="generate-a-key-pair">generate a key-pair</h1>
<p>To generate a public/private key-pair:</p>

<ol>
  <li>generate two (large) random primes, <script type="math/tex">p</script> and <script type="math/tex">q</script></li>
  <li>let <script type="math/tex">n = pq</script></li>
  <li>find <script type="math/tex">\phi(n)</script> (<a href="https://en.wikipedia.org/wiki/Euler's_totient_function">Euler’s totient</a>), or the number of
integers in the range <script type="math/tex">[1, n]</script> that are coprime with <script type="math/tex">n</script> – that is, have a Greatest Common Divisor (GCD) of 1
with it.</li>
  <li>find a value <script type="math/tex">e</script> such that <script type="math/tex">1 \lt e \lt \phi(n)</script> and <script type="math/tex">e</script> is coprime with <script type="math/tex">\phi(n)</script>; this is your <strong>public
key</strong>.</li>
  <li>find a value <script type="math/tex">d</script> such that <script type="math/tex">de \equiv 1 \pmod{\phi(n)}</script> – in other words, find the <a href="https://en.wikipedia.org/wiki/Modular_multiplicative_inverse">multiplicative modular
inverse</a> of <script type="math/tex">e</script> modulo <script type="math/tex">\phi(n)</script>; this is your
<strong>private key</strong>.</li>
</ol>

<p>Though short and concise, the above steps present several complex problems:</p>

<ol>
  <li>generate a large, random prime number; this is probably the most involved, so we’ll save it for last (<strong>step 1</strong>)</li>
  <li>find <script type="math/tex">\phi(n)</script>, where <script type="math/tex">n</script> is the product of two primes (<strong>step 3</strong>)</li>
  <li>find the GCD of two numbers, which will allow us to find <script type="math/tex">e</script> (<strong>step 4</strong>)</li>
  <li>find the multiplicative modular inverse of a value, to find <script type="math/tex">d</script> (<strong>step 4</strong>)</li>
</ol>

<h2 id="example">example</h2>
<p>Before we dive into solving those, let’s walk through the process of generating a key-pair using some small sample
numbers.</p>

<ol>
  <li>let $p = 3$ and $q = 5$</li>
  <li>$n = 3 \cdot 5 = 15$</li>
  <li>$\phi(15) = 8$ (coprime values are 1, 2, 4, 7, 8, 11, 13, and 14)</li>
  <li>$e = 3$, because 3 is both less than and coprime with 8</li>
  <li>$d = 3$, because <script type="math/tex">3 \cdot 3 = 9</script> and <script type="math/tex">9 \equiv 1 \pmod 8</script></li>
</ol>

<p>Easy! Except, of course, we weren’t dealing with numbers with hundreds of digits – that’s the hard part. :)</p>

<h2 id="finding-phin">finding <script type="math/tex">\phi(n)</script></h2>
<p>To compute <script type="math/tex">\phi(n)</script>, we can take advantage of the fact that it’s composed of two <strong>prime</strong> factors: <script type="math/tex">p</script> and <script type="math/tex">q</script>.
Thus, the only values with which it shares GCDs that aren’t 1 must be multiples of either <script type="math/tex">p</script> or <script type="math/tex">q</script> (for instance,
<script type="math/tex">\gcd(n, 2q) = q</script> and <script type="math/tex">\gcd(n, 3p) = p</script>). There are only <script type="math/tex">q</script> multiples of <script type="math/tex">p</script> (<script type="math/tex">p, 2p, 3p, \ldots, qp</script>) and
<script type="math/tex">p</script> multiples of <script type="math/tex">q</script> (<script type="math/tex">q, 2q, 3q, \ldots, qp</script>) that are less than or equal to <script type="math/tex">n</script>. Thus, there are <script type="math/tex">q + p</script>
values in the range <script type="math/tex">[1, n]</script> that have a GCD with <script type="math/tex">n</script> not equal to 1. Note, however, that we double counted <script type="math/tex">pq</script>
in our list of multiples of <script type="math/tex">p</script> and <script type="math/tex">q</script>, so in reality it’s <script type="math/tex">p + q - 1</script>. Thus, <script type="math/tex">\phi(n) = \text{total} - (p + q
-1)</script>, where <script type="math/tex">\text{total}</script> is the total numbers of values in the range <script type="math/tex">[1, n]</script> – that is, <script type="math/tex">n</script>.</p>

<script type="math/tex; mode=display">\phi(n) = n - (p + q - 1) = n - p - q + 1</script>

<h2 id="computing-gcds">computing GCDs</h2>
<p>To find the GCD of two numbers, we’ll employ the <a href="https://en.wikipedia.org/?title=Euclidean_algorithm">Euclidean
algorithm</a>:</p>

<ol>
  <li>the GCD of any number and 0 is the absolute value of that number</li>
  <li>the GCD of numbers <script type="math/tex">a</script> and <script type="math/tex">b</script> is the GCD of <script type="math/tex">b</script> and <script type="math/tex">(a \text{ mod } b)</script></li>
</ol>

<p>or:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">)</span></code></pre></div>

<p>Let’s prove it. Case 1 should be self-explanatory: 0 is technically divisible by any number, even if the quotient
equals 0, so the GCD of 0 and any other number should be that number. We need to be careful and take its absolute
value, however, to account for negative values; the greatest divisor of -5 is 5, after all, not -5, so the
GCD of 0 and -5 must also be 5. Thus, we have to take the absolute value of -5 to arrive at the greatest divisor.</p>

<p>Case 2 is less intuitive (at least for me), and requires proving that <script type="math/tex">\gcd(a, b) = \gcd(b, a \imod b)</script>. Let’s begin
by creating another variable <script type="math/tex">c</script>:</p>

<script type="math/tex; mode=display">c = a - b</script>

<h3 id="prove-gcda-b-divs-c">prove <script type="math/tex">\gcd(a, b) \divs c</script></h3>
<p>We first want to prove that the GCD of <script type="math/tex">a</script> and <script type="math/tex">b</script> divides <script type="math/tex">c</script> (or <script type="math/tex">\gcd(a, b) \divs c</script>). Begin by rewriting
<script type="math/tex">a</script> and <script type="math/tex">b</script> as products of their GCD.</p>

<script type="math/tex; mode=display">a = x \cdot \gcd(a, b)\\
b = y \cdot \gcd(a, b)\\</script>

<p><script type="math/tex">x</script> and <script type="math/tex">y</script> are just placeholders: we don’t want to know or care what they equal. Now, plug those into the
definition of <script type="math/tex">c</script>:</p>

<script type="math/tex; mode=display">c = a - b\\
c = x \cdot \gcd(a, b) - y \cdot \gcd(a, b) = (x - y) \gcd(a, b)\\
\therefore \gcd(a, b) \divs c</script>

<p>Since we’ve shown that <script type="math/tex">c</script> is the product of <script type="math/tex">\gcd(a, b)</script> and another value, it is by definition divisible by
<script type="math/tex">\gcd(a, b)</script>.</p>

<h3 id="prove-gcdb-c-divs-a">prove <script type="math/tex">\gcd(b, c) \divs a</script></h3>
<p>Apply the same logic here:</p>

<script type="math/tex; mode=display">b = x \cdot \gcd(b, c)\\
c = y \cdot \gcd(b, c)\\
a = c + b\\
a = x \cdot \gcd(b, c) + y \cdot \gcd(b, c) = (x + y) \gcd(b, c)\\
\therefore \gcd(b, c) \divs a</script>

<h3 id="prove-gcda-b--gcdb-a---b">prove <script type="math/tex">\gcd(a, b) = \gcd(b, a - b)</script></h3>
<p>We know that, by definition, <script type="math/tex">\gcd(a, b) \divs b</script>, and we’ve proven that <script type="math/tex">\gcd(a, b) \divs c</script>. Thus, <script type="math/tex">\gcd(a, b)</script>
is a <em>common divisor</em> of both <script type="math/tex">b</script> and <script type="math/tex">c</script>. That doesn’t imply that it’s the least common divisor, greatest, or
anything else: all we know is that it divides both numbers. We <em>do</em> know that there exists a <strong>greatest</strong> common
divisor of <script type="math/tex">b</script> and <script type="math/tex">c</script>, <script type="math/tex">\gcd(b, c)</script>, so we can conclude that:</p>

<script type="math/tex; mode=display">\gcd(a, b) \le \gcd(b, c)</script>

<p>We now re-apply that same reasoning. We know that <script type="math/tex">\gcd(b, c) \divs b</script> and <script type="math/tex">\gcd(b, c) \divs a</script>. Thus, <script type="math/tex">\gcd(b,
c)</script> is a common divisor of <script type="math/tex">b</script> and <script type="math/tex">a</script>. Since we know that the <strong>greatest</strong> common divisor of <script type="math/tex">a</script> and <script type="math/tex">b</script> is
<script type="math/tex">\gcd(a, b)</script>, we can conclude that:</p>

<script type="math/tex; mode=display">\gcd(b, c) \le \gcd(a, b)</script>

<p>But now we have two almost contradictory conclusions:</p>

<script type="math/tex; mode=display">\gcd(a, b) \le \gcd(b, c)\\
\gcd(b, c) \le \gcd(a, b)</script>

<p>The only way these can both be true is if:</p>

<script type="math/tex; mode=display">\gcd(a, b) = \gcd(b, c)</script>

<p>So we’ve proven that <script type="math/tex">\gcd(a, b) = \gcd(b, a - b)</script> (remember, <script type="math/tex">c = a - b</script>).</p>

<h3 id="prove-gcdb-a---b--gcdb-a-imod-b">prove <script type="math/tex">\gcd(b, a - b) = \gcd(b, a \imod b)</script></h3>
<p>First, let’s assume that <script type="math/tex">a > b</script>, and rewrite it as: <script type="math/tex">a = bq + r</script> (or <script type="math/tex">r = a \imod b</script>)</p>

<p>Now, we already know that <script type="math/tex">\gcd(a, b) = \gcd(b, a - b)</script>, Since order doesn’t matter, we can rewrite <script type="math/tex">\gcd(b, a -
b)</script> as <script type="math/tex">\gcd(a - b, b)</script>. Now, we apply the rule <script type="math/tex">\gcd(a, b) = \gcd(b, a - b)</script> again.</p>

<script type="math/tex; mode=display">\gcd(a, b) = \gcd(b, a - b) = \gcd(a - b, b)\\
\gcd(a - b, b) = \gcd(b, a - b - b) = \gcd(a - 2b, b)\\
\gcd(a - 2b, b) = \gcd(b, a - 2b - b) = \gcd(a - 3b, b)\\
\gcd(a - 3b, b) = \gcd(b, a - 3b - b) = \gcd(a - 4b, b)\\
\ldots\\
\gcd(a - qb, b) = \gcd(r, b)</script>

<p>or:</p>

<script type="math/tex; mode=display">\gcd(a, b) = \gcd(a - b, b) = \gcd(a - 2b, b) = \ldots = \gcd(a - qb, b) = \gcd(r, b)</script>

<p>Bingo. We’ve proven Case 2, and completed our proof of the Euclidean Algorithm. Before we move on, we’ll also define a
convenience wrapper for <code>gcd()</code> that determines whether two numbers are prime:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">coprime</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span></code></pre></div>

<h2 id="finding-modular-inverses">finding modular inverses</h2>
<p>Given a value <script type="math/tex">a</script> and modulus <script type="math/tex">c</script>, the modular multiplicative inverse of <script type="math/tex">a</script> is a value <script type="math/tex">b</script> that satisfies:</p>

<script type="math/tex; mode=display">ab \equiv 1 \pmod c</script>

<p>This implies that there exists some value <script type="math/tex">d</script> for which:</p>

<script type="math/tex; mode=display">ab = 1 + cd\\
ab - cd = 1</script>

<p>This turns out to be in the form of <a href="https://en.wikipedia.org/wiki/B%C3%A9zout's_identity">Bézout’s identity</a>, which
states that for values <script type="math/tex">m</script> and <script type="math/tex">n</script>, there exist values <script type="math/tex">x</script> and <script type="math/tex">y</script> that satisfy:</p>

<script type="math/tex; mode=display">mx + ny = \gcd(m, n)</script>

<p><script type="math/tex">x</script> and <script type="math/tex">y</script>, called Bézout coefficients, can be solved for using the <a href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm">Extended Euclidean
algorithm</a> (EEA). <script type="math/tex">x</script> corresponds to <script type="math/tex">b</script>, or the
modular inverse that we were looking for, while <script type="math/tex">y</script> can be thrown out once computed. The EEA will also give us the
GCD of <script type="math/tex">m</script> and <script type="math/tex">n</script> – it is, after all, an extension of the Euclidean algorithm, which we use to find the GCD of
two values. We need to verify that it equals 1, since we make the assume that <script type="math/tex">\gcd(m, n) = 1</script>; if it doesn’t, <script type="math/tex">a</script>
has no modular inverse. Since <code>modular_inverse()</code> is just a wrapper for EEA – to be implemented in a function called
<code>bezout_coefficients()</code> – its definition is simple:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">modular_inverse</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">modulus</span><span class="p">):</span>
    <span class="n">coef1</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">gcd</span> <span class="o">=</span> <span class="n">bezout_coefficients</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">modulus</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">coef1</span> <span class="k">if</span> <span class="n">gcd</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="bp">None</span></code></pre></div>

<p><code>bezout_coefficients()</code> is a bit tricker:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">bezout_coefficients</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">quotient</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">coef1</span><span class="p">,</span> <span class="n">coef2</span><span class="p">,</span> <span class="n">gcd</span> <span class="o">=</span> <span class="n">bezout_coefficients</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">remainder</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coef2</span><span class="p">,</span> <span class="n">coef1</span> <span class="o">-</span> <span class="n">quotient</span> <span class="o">*</span> <span class="n">coef2</span><span class="p">,</span> <span class="n">gcd</span></code></pre></div>

<p>Let’s see why it works.</p>

<h3 id="the-extended-euclidean-algorithm">the Extended Euclidean algorithm</h3>
<p>How to solve for <script type="math/tex">x</script> and <script type="math/tex">y</script>? Bezout’s Identity states:</p>

<script type="math/tex; mode=display">\gcd(a, b) = ax + by\\</script>

<p>or, for <script type="math/tex">\gcd(b, a \imod b)</script>:</p>

<script type="math/tex; mode=display">\gcd(b, a \imod b) = bx' + (a \imod b)y'\\</script>

<p>Let’s simplify:</p>

<script type="math/tex; mode=display">a \imod b = a - \lfloor \frac{a}{b} \rfloor b</script>

<p>Here, <script type="math/tex">\lfloor \rfloor</script> represents the <em>floor</em> function, which floors the result of <script type="math/tex">\frac{a}{b}</script> to an integer.</p>

<script type="math/tex; mode=display">\gcd(b, a \imod b) = bx' + (a - \lfloor \frac{a}{b} \rfloor b)y' =\\
  bx' + ay' - \lfloor \frac{a}{b} \rfloor by' =\\
  ay' + b(x' - \lfloor \frac{a}{b} \rfloor y')</script>

<p>Since we know, by the already proven Euclidean algorithm, that <script type="math/tex">\gcd(a, b) = \gcd(b, a \imod b)</script>, we can write:</p>

<script type="math/tex; mode=display">ax + by = ay' + b(x' - \lfloor \frac{a}{b} \rfloor y')</script>

<p>So, <script type="math/tex">x = y'</script> and <script type="math/tex">y = x' - \lfloor \frac{a}{b} \rfloor y'</script>. But what are <script type="math/tex">x'</script> and <script type="math/tex">y'</script>? They’re the results of
running the EEA on <script type="math/tex">(b, a \imod b)</script>! Classic recursion. In sum:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">bezout_coefficients</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">quotient</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">coef1</span><span class="p">,</span> <span class="n">coef2</span> <span class="o">=</span> <span class="n">bezout_coefficients</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">remainder</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">coef2</span><span class="p">,</span> <span class="n">coef1</span> <span class="o">-</span> <span class="n">quotient</span> <span class="o">*</span> <span class="n">coef2</span></code></pre></div>

<p>Of course, we need a base case, or we’ll end up recursing <em>ad infinitum</em>. Let’s take the case of <script type="math/tex">b = 0</script>.</p>

<script type="math/tex; mode=display">ax + by = \gcd(a, b)\\
b = 0\\
ax + 0y = \gcd(a, 0)\\
ax = |a|\\
x = \frac{|a|}{a}</script>

<p>So, if <script type="math/tex">b = 0</script>, we set the <script type="math/tex">x</script> coefficient to 1 if <script type="math/tex">a</script> is positive and -1 is <script type="math/tex">a</script> is negative, and set <script type="math/tex">y</script>
to… what? If <script type="math/tex">b</script> is 0, then <script type="math/tex">y</script> can take on any value. For simplicity’s sake we’ll choose 0. Our revised
definition looks like:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">bezout_coefficients</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">quotient</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">coef1</span><span class="p">,</span> <span class="n">coef2</span> <span class="o">=</span> <span class="n">bezout_coefficients</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">remainder</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coef2</span><span class="p">,</span> <span class="n">coef1</span> <span class="o">-</span> <span class="n">quotient</span> <span class="o">*</span> <span class="n">coef2</span></code></pre></div>

<p>Also note that, since this is simply a more involved version of the Euclidean algorithm (we’re making recursive calls
to <code>bezout_coefficients(b, remainder)</code> and have a base case of <code>b == 0</code>), when we hit the base case, <code>abs(a)</code> is the
GCD of <code>a</code> and <code>b</code>. Since <code>modular_inverse()</code> needs to check that the GCD of its two arguments equals 1, we should
return it in addition to the coefficients themselves. Hence, we’ll let it trickle up from our base case into the final
return value:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">bezout_coefficients</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">quotient</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">coef1</span><span class="p">,</span> <span class="n">coef2</span><span class="p">,</span> <span class="n">gcd</span> <span class="o">=</span> <span class="n">bezout_coefficients</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">remainder</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coef2</span><span class="p">,</span> <span class="n">coef1</span> <span class="o">-</span> <span class="n">quotient</span> <span class="o">*</span> <span class="n">coef2</span><span class="p">,</span> <span class="n">gcd</span></code></pre></div>

<h2 id="generating-large-random-primes">generating large, random primes</h2>
<p>Here’s the idea:</p>

<ol>
  <li>generate a large, random, <strong>odd</strong> number <script type="math/tex">x</script></li>
  <li>check <script type="math/tex">x</script> for primality
    <ol>
      <li>if <script type="math/tex">x</script> prime, return it</li>
      <li>otherwise, increment <script type="math/tex">x</script> by 2, and return to step <strong>2.)</strong></li>
    </ol>
  </li>
</ol>

<p>Easy enough, except for the bit about testing primality. How to do so efficiently? We’ll turn to the
<a href="https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test">Rabin-Miller</a> algorithm, a probabilistic primality
test which either tells us with absolute certainty that a number is composite, or with high likelihood that it’s prime.
We’re fine with a merely probabilistic solution because it’s <em>fast</em>, since speed is a non-negligible issue due to the
size of the numbers that we’re dealing with, and also because the chances of a false positive (ie indicating that a
number is prime when it’s actually composite) are astronomically low after even only a few iterations of the test.</p>

<h3 id="rabin-miller-primality-test">Rabin-Miller primality test</h3>
<p>The Rabin-Miller test relies on the below two assumptions (just accept that they’re true for now, and we’ll prove them
later on). If <script type="math/tex">p</script> is a prime number:</p>

<ol>
  <li><script type="math/tex">a ^ {p - 1} \equiv 1 \pmod p</script> for any <script type="math/tex">a</script> not divisible by <script type="math/tex">p</script></li>
  <li>for any <script type="math/tex">x</script> that satisfies <script type="math/tex">x ^ 2 \equiv 1 \pmod p</script>, <script type="math/tex">x</script> <strong>must</strong> equal ±1</li>
</ol>

<p>Using these, you can test a value <script type="math/tex">n</script> for compositeness like so (note that we return <code>true</code>/<code>false</code> to indicate
definite compositeness/probable primality respectively):</p>

<ol>
  <li>pick a random value <script type="math/tex">a</script> in the range <script type="math/tex">[2, n - 1]</script></li>
  <li>use <strong>assumption 1</strong> to assert that <script type="math/tex">a ^ {n - 1} \equiv 1 \pmod n</script>); if it’s not, return <code>true</code></li>
  <li>if <script type="math/tex">a</script> has an integer square root, let <script type="math/tex">a' = \sqrt a</script>; otherwise, return <code>false</code></li>
  <li>since <script type="math/tex">a' ^ 2 \equiv 1 \pmod n</script>, we can use <strong>assumption 2</strong> to assert that <script type="math/tex">a' \equiv \pm 1 \pmod n</script>; if not,
return <code>true</code></li>
  <li>otherwise, repeat steps 3-4, taking the square root of <script type="math/tex">a'</script>, and the square root of that, and so on, until you
hit a value that doesn’t have an integer square root.</li>
  <li>if you haven’t already returned anything, you’ve satisfied assumptions <strong>1</strong> and <strong>2</strong> for all testable cases and
can return <code>false</code>.</li>
</ol>

<p>In sum, we return <code>true</code> if we’ve confirmed that <script type="math/tex">a</script> is a <em>witness to the compositeness</em> of <script type="math/tex">n</script>, and <code>false</code> if
<script type="math/tex">a</script> does <em>not</em> prove that <script type="math/tex">n</script> is composite – transitively, there is a high chance that <script type="math/tex">n</script> is prime, but we can
only be more sure by running more such tests. While the above steps serve as a good verbal description of the
algorithm, we’ll have to slightly modify them to convert the algorithm into real code.</p>

<p>We need to implement a function <code>is_witness()</code>, which checks whether a random value is a witness to the compositeness
of our prime candidate, <script type="math/tex">n</script>.</p>

<ol>
  <li>write <script type="math/tex">n - 1</script> in the form <script type="math/tex">2 ^ s d</script>. <script type="math/tex">n=73</script>, for instance, would yield <script type="math/tex">s=3</script> and <script type="math/tex">d=9</script>, since <script type="math/tex">73 - 1 =
72 = 2 ^ 3 \cdot 9</script>.</li>
  <li>pick a random value <script type="math/tex">a</script> in the range <script type="math/tex">[2, n - 1]</script>. We’ll check whether this is a witness for <script type="math/tex">n</script>.</li>
  <li>let <script type="math/tex">x = a ^ d \imod n</script></li>
  <li>if <script type="math/tex">x \equiv \pm 1 \pmod n</script>, then return <code>false</code></li>
  <li>repeat <script type="math/tex">s - 1</script> times:
    <ol>
      <li>let <script type="math/tex">x = x ^ 2 \imod n</script></li>
      <li>if <script type="math/tex">x = 1</script>, return <code>true</code></li>
      <li>if <script type="math/tex">x = n - 1</script>, return <code>false</code></li>
    </ol>
  </li>
  <li>if we haven’t returned yet, return <code>true</code></li>
</ol>

<p>These steps seem quite a bit different from before, but in reality, they’re exactly the same and just operating in
reverse. We start with a value that doesn’t have an integer square root, and square it until we hit <script type="math/tex">a ^ {n - 1}</script>.
Why did we bother decomposing <script type="math/tex">n - 1</script> into the form of <script type="math/tex">2 ^ s d</script>? Well, it allows us to rewrite <script type="math/tex">a ^ {n - 1}</script>
as <script type="math/tex">a ^ {2 ^ s d}</script>, and now we know <strong>exactly</strong> how many times we can take square roots before we hit a value that
isn’t reducible any further – in this case, <script type="math/tex">a ^ d</script>.</p>

<script type="math/tex; mode=display">a_1 = \sqrt{a ^ {2 ^ s d}} = (a ^ {2 ^ s d}) ^ \frac{1}{2} = a ^ {\frac{1}{2} \cdot 2 \cdot 2 ^ {s - 1} d} =
  a ^ {2 ^ {s - 1} d}\\
a_2 = \sqrt{a ^ {2 ^ {s - 1} d}} = (a ^ {2 ^ {s - 1} d}) ^ \frac{1}{2} = a ^ {\frac{1}{2} \cdot 2 \cdot 2 ^ {s - 2} d}
  = a ^ {2 ^ {s - 2} d}\\
\ldots\\
a_{last} = a ^ d</script>

<p>So, if we start with <script type="math/tex">a ^ d</script> and square it, we’ll get <script type="math/tex">a ^ {2d}</script>, then <script type="math/tex">a ^ {2 ^ 2 d}</script>, then <script type="math/tex">a ^ {2 ^ 3 d}</script>,
and ultimately <script type="math/tex">a ^ {2 ^ s d}</script>, or <script type="math/tex">a ^ {n - 1}</script>. What’s the advantage of starting from the non-reducible value and
squaring it, rather than the reducible value and taking its square roots? It sometimes allows us to short-circuit the
process. For instance, as we iterate through the squares of <script type="math/tex">a ^ d</script>, if we find an occurrence of -1, we know that
we’ll get 1 when we square it, and 1 when we square that, and keep on getting 1s until we stop iterating. As a
consequence, we know that we won’t find any failing conditions, and can exit early by returning <code>false</code> (<strong>step 5.3</strong>).
The same goes for <strong>step 4</strong>: if <script type="math/tex">a ^ d \equiv \pm 1 \pmod n</script>, we know that each of the following squares will equal
1, so we immediately return <code>false</code>.</p>

<p>The failing conditions – ie those that cause the algorithm to return <code>true</code> – might not be immediately clear. In
<strong>5.2</strong>, we know that, if <script type="math/tex">x = 1</script>, we’ve violated <strong>assumption 2</strong>, because that implies that the previous value of
<script type="math/tex">x</script> was not equivalent to <script type="math/tex">\pm 1 \pmod n</script>. Wait, why? Because if it were equal to -1, we would’ve already returned
via <strong>5.3</strong> in the previous iteration, and if it were <script type="math/tex">1</script>, then we would’ve returned either from <strong>5.3</strong> in an
earlier iteration still or <strong>4</strong> at the very beginning. We also return <code>true</code> when we hit <strong>6</strong>, because we know that
by that point, if <strong>assumption 1</strong> is:</p>

<ol>
  <li>true, and <script type="math/tex">x = a ^ {n - 1} \equiv 1 \pmod n</script>, then the previous value of <script type="math/tex">x</script> can’t be either 1 or -1 because
we would already have returned via either <strong>4</strong> or <strong>5.3</strong>.</li>
  <li>false, then by definition <script type="math/tex">n</script> can’t be prime, since the assumption <em>must</em> hold true for prime <script type="math/tex">n</script></li>
</ol>

<p>Finally, we simply repeat the <code>is_witness()</code> test <script type="math/tex">k = 5</script> times. Here’s the final implementation:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="n">s</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">decompose_to_factors_of_2</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_witness</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">modular_power</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">modular_power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>

            <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>

        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_witness</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="k">return</span> <span class="bp">True</span>

<span class="k">def</span> <span class="nf">decompose_to_factors_of_2</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">num</span>

    <span class="k">while</span> <span class="n">d</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">//=</span> <span class="mi">2</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span></code></pre></div>

<p>Note that we’ve introduced a currently undefined function, <code>modular_power()</code>. The problem with computing <script type="math/tex">a ^ d \imod
n</script> and <script type="math/tex">x ^ 2 \imod n</script> is that <script type="math/tex">a</script>, <script type="math/tex">d</script>, <script type="math/tex">x</script>, and <script type="math/tex">n</script> are <strong>HUGE</strong>. Simply running <code>(a ** d) % n</code> would be
asking for trouble. Fortunately, there are efficient ways of performing modular exponentiation, and we’ll implement
one such method in the <code>modular_power()</code> function later in this article. Now, we need to actually prove the two
assumptions that we base Rabin-Miller on.</p>

<h4 id="euclids-lemma">Euclid’s lemma</h4>
<p>…but before we do so, we need to prove <a href="https://en.wikipedia.org/wiki/Euclid's_lemma">Euclid’s Lemma</a>, since both of
the following proofs depend on it. It states that if <script type="math/tex">p</script> is relatively prime to <script type="math/tex">a</script> and <script type="math/tex">p \divs ab</script>, then <script type="math/tex">p
\divs b</script>. We’ll prove it using Bezout’s Identity. The GCD of <script type="math/tex">a</script> and <script type="math/tex">p</script> is 1, so there must exist <script type="math/tex">x</script> and <script type="math/tex">y</script>
that satisfy:</p>

<script type="math/tex; mode=display">ax + py = 1</script>

<p>Multiply both sides by <script type="math/tex">b</script>:</p>

<script type="math/tex; mode=display">abx + pby = b</script>

<p><script type="math/tex">abx</script> is divisible by <script type="math/tex">p</script> (because it’s divisible by <script type="math/tex">ab</script>, which is divisible by <script type="math/tex">p</script> according to the lemma’s
requisite), and <script type="math/tex">pby</script> is by definition divisible by <script type="math/tex">p</script>, so <script type="math/tex">b</script> must be divisible by <script type="math/tex">p</script> too.</p>

<h4 id="proof-of-assumption-1">proof of assumption 1</h4>
<p>Our first assumption was that for a prime <script type="math/tex">p</script>, <script type="math/tex">a ^ {p - 1} \equiv 1 \pmod p</script> for any <script type="math/tex">a</script> <strong>not divisible by
<script type="math/tex">p</script></strong>. This is better known as <a href="https://en.wikipedia.org/wiki/Fermat's_little_theorem">Fermat’s Little Theorem</a>. To
prove it, begin by multiplying all of the numbers in the range <script type="math/tex">[1, p)</script> by <script type="math/tex">a</script>:</p>

<script type="math/tex; mode=display">a, 2a, 3a, \ldots, (p - 1) a</script>

<p>We make two observations:</p>

<ol>
  <li>
    <p>given two values <script type="math/tex">x</script> and <script type="math/tex">y</script>, <script type="math/tex">ax \equiv ay \pmod p</script> is equivalent to <script type="math/tex">x \equiv y \pmod p</script> (we effectively
divide out <script type="math/tex">a</script>). We can prove this by rewriting <script type="math/tex">ax \equiv ay \pmod p</script> as <script type="math/tex">ax - ay \equiv 0 \pmod p</script>, which
implies that <script type="math/tex">p \divs ax - ay</script>, or <script type="math/tex">p \divs a(x - y)</script>. By Euclid’s Lemma, since <script type="math/tex">p</script> and <script type="math/tex">a</script> are coprime
(reminder: this is a criterion of Fermat’s Little Theorem), <script type="math/tex">p \divs x - y</script>, which means we can write <script type="math/tex">x - y
\equiv 0 \pmod p</script>, or <script type="math/tex">x \equiv y \pmod p</script>.</p>
  </li>
  <li>
    <p>when each of its elements is simplified in <script type="math/tex">\imod p</script>, the above sequence is simply a rearrangement of <script type="math/tex">1, 2,
\ldots, p - 1</script>. This is true because, firstly, its values all lie in the range <script type="math/tex">[1, p)</script> – none can equal 0
since <script type="math/tex">p</script> shares no factors other than 1 with either <script type="math/tex">a</script> or any value in <script type="math/tex">1, 2, \ldots, p - 1</script> due to its
primeness. The trick now is to realize that, if we have two distinct values <script type="math/tex">x</script> and <script type="math/tex">y</script>, and know that <script type="math/tex">ax
\equiv ay \pmod p</script>, then by the previous observation we can “divide out <script type="math/tex">a</script>” and have <script type="math/tex">x \equiv y \pmod p</script>.
If <script type="math/tex">x</script> and <script type="math/tex">y</script> were two values chosen from the <script type="math/tex">1, \ldots, p - 1</script> sequence, we’d know that they’re all less
than <script type="math/tex">p</script>, and can thus remove the <script type="math/tex">\imod p</script> from the expression, leaving us with: <script type="math/tex">x = y</script>. In conclusion,
the only way to satisfy <script type="math/tex">ax \equiv ay \imod p</script> is to have <script type="math/tex">x</script> be the same item as <script type="math/tex">y</script>, and that means that
the distinct values in <script type="math/tex">a, \ldots, (p - 1) a</script> map to distinct values in <script type="math/tex">1, \ldots, p - 1</script>.</p>
  </li>
</ol>

<p>By <strong>observation 1</strong>:</p>

<script type="math/tex; mode=display">a \cdot 2a \cdot \ldots \cdot (p - 1) a \equiv 1 \cdot 2 \cdot \ldots \cdot (p - 1) \pmod p\\
a ^ {p - 1} (p - 1)! \equiv (p - 1)! \pmod p</script>

<p>By <strong>observation 2</strong>, we can cancel out each of the factors of <script type="math/tex">(p - 1)!</script> from both sides of the expressions (after
all, <script type="math/tex">p</script> is prime and all of the factors of <script type="math/tex">(p - 1)!</script> are less than it, so it’s coprime with all of them), which
leaves us with:</p>

<script type="math/tex; mode=display">a ^ {p - 1} \equiv 1 \pmod p</script>

<p>QED.</p>

<h4 id="proof-of-assumption-2">proof of assumption 2</h4>
<p>We now prove assumption 2: if <script type="math/tex">p</script> is prime and <script type="math/tex">x ^ 2 \equiv 1 \pmod p</script>, <script type="math/tex">x</script> must equal <script type="math/tex">\pm 1 \imod p</script>. First,
for greater clarity later on, we can rewrite our conclusion as: <script type="math/tex">p</script> must divide either <script type="math/tex">x - 1</script> or <script type="math/tex">x + 1</script>. Now,
if <script type="math/tex">x ^ 2 \equiv 1 \pmod p</script>, then:</p>

<script type="math/tex; mode=display">x ^ 2 - 1 \equiv 0 \pmod p\\
p \divs x ^ 2 - 1\\
p \divs (x - 1)(x + 1)</script>

<p>If <script type="math/tex">p</script> divides <script type="math/tex">x - 1</script>, then:</p>

<script type="math/tex; mode=display">x - 1 \equiv 0 \pmod p\\
x \equiv 1 \pmod p</script>

<p>and we’ve proven our conclusion. What if <script type="math/tex">p</script> <em>doesn’t</em> divide <script type="math/tex">x - 1</script>? We can then leverage Euclid’s Lemma: if
<script type="math/tex">p</script> is relatively prime to <script type="math/tex">a</script> and <script type="math/tex">p \divs ab</script>, then <script type="math/tex">p \divs b</script>. We know that <script type="math/tex">p</script> is prime and doesn’t
divide <script type="math/tex">x - 1</script>, so it’s relatively prime to <script type="math/tex">x - 1</script>, and we know that it divides <script type="math/tex">(x - 1)(x + 1)</script>. As a result,
it has to divide <script type="math/tex">x + 1</script>, which implies that: <script type="math/tex">x \equiv -1 \pmod p</script>. Again, we’ve proven our conclusion, and thus
proven assumption 2.</p>

<h3 id="applying-rabin-miller">applying Rabin-Miller</h3>
<p>Now that we’ve implemented Rabin-Miller, creating a large, random prime is almost trivial:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">get_random_prime</span><span class="p">(</span><span class="n">num_bits</span><span class="p">):</span>
    <span class="n">lower_bound</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">num_bits</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">upper_bound</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">num_bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">guess</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">guess</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">guess</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="ow">not</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">guess</span><span class="p">):</span>
        <span class="n">guess</span> <span class="o">+=</span> <span class="mi">2</span>

    <span class="k">return</span> <span class="n">guess</span></code></pre></div>

<p>The <code>num_bits</code> parameter is a bit of a weird way of specifying the desired size of the prime, but it’ll make sense
since we usually want to create RSA keys of a specific bit-length (more on this later on).</p>

<h2 id="wrapping-it-all-up">wrapping it all up</h2>
<p>At long last, we can define our <code>create_key_pair()</code> function.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">create_key_pair</span><span class="p">(</span><span class="n">bit_length</span><span class="p">):</span>
    <span class="n">prime_bit_length</span> <span class="o">=</span> <span class="n">bit_length</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">get_random_prime</span><span class="p">(</span><span class="n">prime_bit_length</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">get_random_prime</span><span class="p">(</span><span class="n">prime_bit_length</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">q</span>
    <span class="n">totient</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">e_candidate</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">totient</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">e_candidate</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">e_candidate</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">coprime</span><span class="p">(</span><span class="n">e_candidate</span><span class="p">,</span> <span class="n">totient</span><span class="p">):</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">e_candidate</span>
            <span class="k">break</span>

    <span class="n">d</span> <span class="o">=</span> <span class="n">modular_inverse</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">totient</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">e</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span></code></pre></div>

<p>The only thing that requires explanation is this <code>bit_length</code> business. The idea here is that we generally want to
create RSA keys of a certain bit-length (1024 and 2048 are common values), so we pass in a parameter specifying the
length. To make sure that <script type="math/tex">n</script> has a bit-length approximately equal to <code>bit_length</code>, we need to make sure that the
primes <script type="math/tex">p</script> and <script type="math/tex">q</script> that we use to create it have a bit length of <code>bit_length / 2</code>, since multiplying two <script type="math/tex">n</script>-bit
numbers yields an approximately <script type="math/tex">2n</script>-bit value. How come? The number of bits in a positive integer <script type="math/tex">n</script> is
<script type="math/tex">\lfloor \log_2 n \rfloor + 1</script>, so the number of bits in <script type="math/tex">n ^ 2</script> is <script type="math/tex">\lfloor \log_2 n ^ 2\rfloor + 1</script>. According
to the <a href="http://www.rapidtables.com/math/algebra/logarithm/Logarithm_Rules.htm#power rule">logarithm power rule</a>, we can
rewrite <script type="math/tex">\log{a ^ b}</script> as <script type="math/tex">b \cdot \log a</script>, so the bit length equals <script type="math/tex">\lfloor 2\log_2 n \rfloor + 1</script>. In other
words, <script type="math/tex">n ^ 2</script> has roughly twice as many bits as <script type="math/tex">n</script>.</p>

<h1 id="encryptdecrypt-messages">encrypt/decrypt messages</h1>
<p>In comparison to generating keys, encrypting and decrypting data with them is mercifully simple.</p>

<ol>
  <li>encrypt a message <script type="math/tex">m</script> with public key <script type="math/tex">e</script> and modulus <script type="math/tex">n</script>: <script type="math/tex">m ^ e \imod n</script></li>
  <li>decrypt a message <script type="math/tex">c</script> with private key <script type="math/tex">d</script> and modulus <script type="math/tex">n</script>: <script type="math/tex">c ^ d \imod n</script></li>
</ol>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">modular_power</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">decrypt</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">modular_power</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span></code></pre></div>

<p>So, what’s <code>modular_power()</code>? The problem with the encryption and decryption operations, which look
deceptively trivial, is that all of the values involved are big. Really, really big. As a result, naively solving <script type="math/tex">a ^
b \imod c</script> by simply resolving <script type="math/tex">a ^ b</script> and then simplifying that modulo <script type="math/tex">c</script> is a no-go. Fortunately, there are
more efficient ways of performing <a href="https://en.wikipedia.org/wiki/Modular_exponentiation">modular exponentiation</a>, like
exponentiation by squaring.</p>

<h2 id="exponentiation-by-squaring">exponentiation by squaring</h2>
<p>When trying to solve <script type="math/tex">a ^ b \imod c</script>, begin by representing <script type="math/tex">b</script> in binary form:</p>

<script type="math/tex; mode=display">b = 2 ^ {n - 1} bit_{n - 1} + 2 ^ {n - 2} bit_{n - 2} + \ldots + 2 bit_1 + bit_0</script>

<p>where <script type="math/tex">n</script> is the total number of bits in <script type="math/tex">b</script>, and <script type="math/tex">bit</script> represents the value of each bit – either 0 or 1. Now,
rewrite the original expression:</p>

<script type="math/tex; mode=display">a ^ b \imod c =\\
a ^ {2 ^ {n - 1} bit_{n - 1} + 2 ^ {n - 2} bit_{n - 2} + \ldots + 2 bit_1 + bit_0} \imod c =\\
a ^ {2 ^ {n - 1} bit_{n - 1}} \cdot a ^ { 2 ^ {n - 2} bit_{n - 2}} \cdot \ldots \cdot a ^ {2 bit_1} \cdot a ^ {bit_0}
  \imod c\\</script>

<p>For illustrative purposes, let’s temporarily remove the <script type="math/tex">bit</script> factor from each exponent, which leaves us with:</p>

<script type="math/tex; mode=display">a ^ {2 ^ {n - 1}} \cdot a ^ { 2 ^ {n - 2}} \cdot \ldots \cdot a ^ {2} \cdot a \imod c</script>

<p>It’s now obvious that each factor is a square of the one that precedes it: <script type="math/tex">a ^ {2}</script> is the square of <script type="math/tex">a</script>,
<script type="math/tex">a ^ {2 ^ {n - 1}}</script> is the square of <script type="math/tex">a ^ { 2 ^ {n - 2}}</script>, etc. If we were to programmatically solve the
expression, we could maintain a variable, say <code>accumulator</code>, that we’d initialize to <script type="math/tex">a</script>, and square from
factor to factor to avoid recomputing <script type="math/tex">a ^ {\text{big exponent}}</script> every time. Now, let’s reintroduce <script type="math/tex">bit</script>:</p>

<script type="math/tex; mode=display">a ^ {2 ^ {n - 1} bit_{n - 1}} \cdot a ^ { 2 ^ {n - 2} bit_{n - 2}} \cdot \ldots \cdot a ^ {2 bit_1} \cdot a ^ {bit_0}
  \imod c\\</script>

<p>The good thing is that <script type="math/tex">bit</script> has a limited set of possible values: just 0 and 1! Any value in the form
<script type="math/tex">a ^ {2 ^ p bit}</script> – that is, all of the above factors – evaluates to <script type="math/tex">a ^ {2 ^ p}</script> when <script type="math/tex">bit = 1</script>,
and <script type="math/tex">a ^ 0</script>, or 1, when <script type="math/tex">bit = 0</script>. In other words, the value of <script type="math/tex">bit</script> only controls whether or not we multiply
one of the factors into the accumulator that’ll become our ultimate result (since if <script type="math/tex">bit = 0</script>, we’ll just end up
multiplying in 1, which means we shouldn’t even bother). Thus, <code>modular_power()</code> might look something like this:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">modular_power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">modulus</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="n">exp</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">exp</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">*</span> <span class="n">base</span>
        <span class="n">exp</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">base</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="k">return</span> <span class="n">result</span> <span class="o">%</span> <span class="n">modulus</span></code></pre></div>

<p>But we still haven’t addressed the issue of multiplying huge numbers by huge numbers, and this version of
<code>modular_power()</code> doesn’t perform much better than <code>(base ** exp) % modulus</code> (in fact, after some spot checking, it
appears to be much slower!). We can address that by taking advantage of the following property of modular
multiplication:</p>

<script type="math/tex; mode=display">xy \imod z = (x \imod z)(y \imod z) \imod z</script>

<p>We can prove it by rewriting <script type="math/tex">x</script> and <script type="math/tex">y</script> in terms of <script type="math/tex">z</script>:</p>

<script type="math/tex; mode=display">x = q_x z + r_x\\
y = q_y z + r_y</script>

<p>and substituting that into the original expression:</p>

<script type="math/tex; mode=display">xy \imod z =\\
(q_x z + r_x) (q_y z + r_y) \imod z =\\
q_x q_y z ^ 2 + q_x z r_y + r_x q_y z + r_x r_y \imod z =\\
z(q_x q_y z + q_x r_y + r_x q_y) + r_x r_y \imod z =\\
r_x r_y \imod z</script>

<p>We’re able to remove the entire chunk of the expression that gets multiplied by <script type="math/tex">z</script> because it’s by definition
divisible by <script type="math/tex">z</script>, meaning that, taken <script type="math/tex">\imod z</script>, it would equal 0, and wouldn’t contribute anything to the sum.
Thus, <script type="math/tex">xy \imod z</script> equals <script type="math/tex">r_x r_y \imod z</script>, or <script type="math/tex">(x \imod z)(y \imod z) \imod z</script>.</p>

<p>Using that, we can make the following adjustment to our initial implementation:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">modular_power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">modulus</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">base</span> <span class="o">%=</span> <span class="n">modulus</span>

    <span class="k">while</span> <span class="n">exp</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">exp</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span> <span class="o">*</span> <span class="n">base</span><span class="p">)</span> <span class="o">%</span> <span class="n">modulus</span>
        <span class="n">exp</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
        <span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="n">base</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">modulus</span>

    <span class="k">return</span> <span class="n">result</span></code></pre></div>

<p>We’re now taking <code>% modulus</code> in a bunch of places, which is valid due to the above property and prevents the value of
both <code>result</code> and <code>base</code> from growing out of control.</p>

<p>That tops off our implementation of RSA. <a href="http://files.sevko.io/rsa/rsa.py">Here’s</a> the entire source file.</p>

<h1 id="acknowledgements">acknowledgements</h1>
<p>I wouldn’t have been able to present most of the proofs in this article without help from the following sources. One of
the key motivations for gathering them all in one post is that, as I tried to understand all of the moving parts of
RSA, I needed to sift through <em>a lot</em> of material to find accessible and satisfactory explanations:</p>

<ul>
  <li><a href="https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/the-euclidean-algorithm">the Euclidean algorithm</a></li>
  <li><a href="http://pages.pacificcoast.net/~cazelais/222/xeuclid.pdf">the Extended Euclidean algorithm</a></li>
  <li><a href="https://en.wikipedia.org/?title=Proofs_of_Fermat%27s_little_theorem">Fermat’s Little Theorem</a></li>
  <li><a href="http://home.sandiego.edu/~dhoffoss/teaching/cryptography/10-Rabin-Miller.pdf">Rabin-Miller test</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Modular_exponentiation#Right-to-left_binary_method">exponentiation by squaring</a></li>
</ul>
>
				</content>
				<pubDate>Sun, 14 Jun 2015 22:00:00 +0100</pubDate>
				<link>http://sevko.io/articles/rsa</link>
				<guid isPermaLink="true">http://sevko.io/articles/rsa</guid>
			</item>
		
			<item>
				<title>nand2tetris: a book review and recap</title>
				
					<category>book review></category>
				
					<category>computer engineering></category>
				
				<description>what is Nand2Tetris?
Nand2Tetris, or The Elements of Computing Systems, is a twelve-part course in
fundamental computer engineering that steps you through the creation of a computer from the ground up, starting with
NAND logic gates and ending with an operating system capable of running a complicated program like Tetris.

</description>
				<image>
					<url>http://www.w3schools.com/images/logo.gif</url>
					<title>The cover of Nand2Tetris.</title>
					<link>http://files.sevko.io/img/thumbnails/nand2tetris_review.png</link>
				</image>
				<content type="html">
					
					<h1 id="what-is-nand2tetris">what is Nand2Tetris?</h1>
<p><a href="http://www.nand2tetris.org/">Nand2Tetris</a>, or <em>The Elements of Computing Systems</em>, is a twelve-part course in
fundamental computer engineering that steps you through the creation of a computer from the ground up, starting with
NAND logic gates and ending with an operating system capable of running a complicated program like Tetris.</p>

<p>The course, architected by <a href="http://www.cs.huji.ac.il/~noam/">Noam Nisan</a> and
<a href="http://shimonschocken.com/">Shimon Schocken</a>, is available as a
<a href="http://www.amazon.com/The-Elements-Computing-Systems-Principles/dp/0262640686">book</a> that you can
download for <a href="http://www1.idc.ac.il/tecs/plan.html">free</a> (though it appears that some chapters are only available in
terse PowerPoint form), and emphasizes a hands-on approach that leads up to some pretty epic struggles and <em>Aha!</em>
moments. I just recently finished the course after about two months of hacking on it in my free time – if you reliably
spend a couple hours a day on it, though, I can easily see you finishing in two weeks – and wanted to share an
overview of the content and some thoughts.</p>

<p><img src="http://files.sevko.io/nand2tetris_review/book.png" alt="The cover of The Elements of Computing Systems." /></p>

<h1 id="content-overview">content overview</h1>

<div class="quote">
	Once upon a time, every computer specialist had a gestalt understanding of how computers worked. The overall
	interactions among hardware, software, compilers, and the operating system were simple and transparent enough to
	produce a coherent picture of the computer’s operations. As modern computer technologies have become increasingly
	more complex, this clarity is all but lost: the most fundamental ideas and techniques in computer science—the very
	essence of the field—are now hidden under many layers of obscure interfaces and proprietary implementations. An
	inevitable consequence of this complexity has been specialization, leading to computer science curricula of many
	courses, each covering a single aspect of the field.

	<div>
		Elements of Computing Systems: Preface
	</div>
</div>

<p><em>Nand2Tetris</em> consists of twelve lectures/chapters, each of which tackles a next logical step in building a computer
called “Hack,” and iterates on all of your work up to that point. Note that the book ships with various supplementary
materials (which you can download <a href="http://www.nand2tetris.org/software.php">here</a>), including emulators for various
components of the computer, like the hardware, stack, and virtual machine. Here’s an overview the ground you’ll cover:</p>

<p><img src="http://files.sevko.io/nand2tetris_review/overview.png" alt="An overview of the Nand2Tetris pipeline." /></p>

<p>I’ll briefly summarize the contents of each chapter (partly as a review for myself).</p>

<h2 id="boolean-logic">1: boolean logic</h2>
<p>We learn about <a href="http://computer.howstuffworks.com/boolean.htm">boolean logic</a>, or logic with boolean values –
conveniently, <code>0</code>s and <code>1</code>s – that facilitate logical/mathematical operations in hardware. We then construct primitive
<a href="http://en.wikipedia.org/wiki/Logic_gate">logic gates</a>, like <code>AND</code>, <code>OR</code>, and <code>MUX</code>, which operate on single-bit
inputs, and chain those together to implement their multi-bit (in this case, the <em>Hack</em>
<a href="http://en.wikipedia.org/wiki/Word_%28computer_architecture%29">word</a>, or two bytes) counterparts, like <code>AND16</code>.</p>

<h2 id="boolean-arithmetic">2: boolean arithmetic</h2>
<p>We cover binary addition and <a href="http://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.html">two’s complement</a>, a means of
representing <em>signed</em> numbers (in other words, negative and positive values instead of positive values only), and
implement <em>adder</em> chips to perform addition at the hardware level. Finally, we devise an
<a href="http://www.computerhope.com/jargon/a/alu.htm">ALU</a> (<b>A</b>rithmetic <b>L</b>ogic <b>U</b>nit), which implements
addition and value comparisons (ie, logic operations), but, unlike industrial-grade hardware, <em>not</em> either of
multiplication and division.  We’ll implement those operations at the software level – specifically, in the operating
system’s math standard library – in the interest of simplicity, but at the expense of speed.</p>

<h2 id="sequential-logic">3: sequential logic</h2>
<p>Throughout chapters 1 and 2 we implemented <em>combinational</em> chips using <strong>NAND</strong> gates, and got
arithmetic/logic out of the way. This section introduces a new fundamental building block: the
<a href="http://hyperphysics.phy-astr.gsu.edu/hbase/electronic/dflipflop.html">DFF</a>, or <b>D</b>ata <b>F</b>lip <b>F</b>lop,
which will allow us to construct the second crucial component of our <em>Hack</em> computer – memory. Unlike <em>combinational</em>
chips, which simply intake arguments via input pins and “immediately” spit out a result to output pins and are thus
<em>stateless</em>, the <em>sequential</em> circuits that we’ll implement with flip-flops are capable of maintaining values across
time. Note that, even though we treat the <em>DFF</em> as a fundamental chip, it can be implemented <a href="http://en.wikipedia.org/wiki/Flip-flop_%28electronics%29#SR_NAND_latch">using NAND
gates</a> and more – Nand2Tetris just
thoughtfully spares us that gory implementation. We implement a <code>Bit</code>, <code>Register</code>, and multiple <code>RAM</code> chips with
iteratively larger capacities (64-word RAM consists of 8-word RAM, 512 of 64, etc.), and also a <em>program counter</em>,
which we’ll use to keep track of the next CPU instruction to execute. This <em>sequential</em> business is a little
mind-bending (and quite cool) because it effectively makes use of delayed recursion in a hardware context.</p>

<h2 id="machine-language">4: machine language</h2>
<p>We’re introduced to the <em>Hack</em> <a href="http://en.wikipedia.org/wiki/Machine_code">machine language</a>, or the format of the
binary strings that our CPU (to be implemented in the next chapter) will interpret as instructions, and its
correspondent <a href="http://en.wikipedia.org/wiki/Assembly_language">assembly language</a>: this is <em>the</em> interface between
hardware and software. Assembly is a human-readable representation of machine code which allows instructions to be
written with mnemonics like <code>ADD</code> or <code>SUB</code>; those are then compiled down to the appropriate binary by an <em>assembler</em>
(to be implemented in chapter 6) – essentially a glorified preprocessor. Here’s an example of <em>Hack</em> assembly:</p>

<div class="highlight"><pre><code class="language-text" data-lang="text">(LOOP)
	@END
	D;JEQ

	@sum
	M=M+D
	D=D-1

	@LOOP
	0;JMP</code></pre></div>

<p>The above code adds all consecutive integers between 0 and some number, storing the sum in a variable <code>sum</code>.</p>

<h2 id="computer-architecture">5: computer architecture</h2>
<p>We implement the <em>Hack</em> CPU, which abstracts away all hardware operations and exposes an API for executing them – that
is, the machine language. The CPU integrates chapters 2 (the <code>ALU</code>) and 3 (<code>RAM</code>) in a classic mold of the
<a href="http://www.teach-ict.com/as_as_computing/ocr/H447/F453/3_3_3/vonn_neuman/miniweb/pg3.htm">von Neumann</a> architecture:</p>

<p><img src="http://files.sevko.io/nand2tetris_review/von_neumann.png" alt="A diagram of the von Neumann computer architecture." /></p>

<h2 id="assembler">6: assembler</h2>
<p>Assembly! Everyone loves assembly! This section extends chapter 4, which documented the <em>Hack</em> assembly language spec.,
and has you implement the assembler that translates such programs to binary machine instructions.</p>

<h2 id="virtual-machine">7, 8: virtual machine</h2>
<p>We learn about <em>virtual machines</em>, or <strong>platform-independent</strong> runtime environments that allow high-level languages to
compile down to a portable <a href="http://cs.lmu.edu/~ray/notes/ir/">intermediate representation</a>, or IR, (in this case, the
virtual machine language) that will run on any chip-set with an implementation of that virtual machine. Basically,
since different CPUs potentially have different machine languages, writing native compilers for high-level languages
would be a nightmare because the output binaries would have to be tweaked on a per-system basis. A virtual machine
handles that concern by itself exposing an interface – in the form of a virtual machine language, or IR – for
performing memory, logic, and math operations that target systems can reliably be expected to support.
Platform-specific compilers that convert the IR to assembly <em>do</em> have to be written, but that problem is now
centralized in one place; high-level language developers don’t have to worry about re-inventing the same compilation
wheel if they build their language around the same virtual machine, instead leaving that problem to the virtual machine
maintainers.</p>

<p><img src="http://files.sevko.io/nand2tetris_review/virtual_machine.png" alt="A simple diagram of a virtual machine." /></p>

<p>Anyway, the <em>Hack</em> virtual machine wraps its assembly language in a simple, stack-based interface. We implement the
IR-to-assembly compiler, which becomes tricky once we involve things like stack frames. Sample code looks like:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">function</span> <span class="n">Point</span><span class="o">.</span><span class="n">new</span> <span class="mi">0</span>
	<span class="n">push</span> <span class="n">constant</span> <span class="mi">2</span>
	<span class="n">call</span> <span class="n">Memory</span><span class="o">.</span><span class="n">alloc</span> <span class="mi">1</span>
	<span class="n">pop</span> <span class="n">pointer</span> <span class="mi">0</span>
	<span class="n">push</span> <span class="n">argument</span> <span class="mi">0</span>
	<span class="n">pop</span> <span class="n">this</span> <span class="mi">0</span>
	<span class="n">push</span> <span class="n">argument</span> <span class="mi">1</span>
	<span class="n">pop</span> <span class="n">this</span> <span class="mi">1</span>
	<span class="n">push</span> <span class="n">pointer</span> <span class="mi">0</span>
	<span class="k">return</span></code></pre></div>

<h2 id="high-level-language">9: high-level language</h2>
<p>We’re introduced to the spec for a high-level, object-oriented language (without garbage collection) not unlike Java,
called <em>Jack</em>. The following <em>Jack</em> code defines a class <code>Point</code>, which represents a 2D geometric point:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
	<span class="n">field</span> <span class="kt">int</span> <span class="n">_x</span><span class="o">,</span> <span class="n">_y</span><span class="o">;</span>

	<span class="n">constructor</span> <span class="n">Point</span> <span class="nf">new</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
		<span class="n">let</span> <span class="n">_x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
		<span class="n">let</span> <span class="n">_y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
		<span class="k">return</span> <span class="k">this</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span></code></pre></div>

<h2 id="compiler">10, 11: compiler</h2>
<p>We implement a <em>Jack</em> compiler, which converts <em>Jack</em> programs to <em>Hack</em> virtual machine code. We learn about basic
compilation techniques – tokenization, recursive-descent parsers – and features – symbol tables, parse trees.</p>

<h2 id="operating-system">12: operating system</h2>
<p>Finally, we implement the <em>Hack</em> operating system (using <em>Jack</em>), which only consists of a number of standard system
libraries that govern things like math, memory management, and graphics. The chapter centers heavily on algorithms,
introducing some fascinating optimized approaches to problems including multiplication and heap allocation.</p>

<h1 id="review-and-advice">review and advice</h1>
<p>That was a pretty wild ride. I heard about <em>The Elements of Computing Systems</em> nearly two years ago and kept it on the
back-burner ever since, and am very glad I finally got around to reading it. Nisan and Schocken succeeded tremendously
in what they set out to accomplish – creating a course that gives you a universal, if shallow, understanding of
the entire hardware and software stack that computers operate on.</p>

<p>The individual sections are clear and concise, with just enough technical and academic background, examples, and
project walkthroughs, and benefit from a uniform structure. Each project assignment involves a good deal of
steering, as the authors underscore the <em>suggested</em> (though probably always the way you’d want to go anyway) approach to
implementing the next stage of the computer, but with nothing in the way of concrete implementations – this encourages
the reader to wet their feet and, in true hacker fashion, build the thing on their own. The software package that ships
with the course is entirely bug-free, and the emulators are both user-friendly and robust (these things are easy to
take for granted…).</p>

<p>An enormous amount of thought was clearly invested in the structure of the course. The various components of the <em>Hack</em>
system have perfectly coupled interrelationships, and your work up to any single point almost magically helps you
bootstrap the next project with incredible ease – this is mostly true for the hardware sections of the course, where
chip creation is a <em>highly</em> iterative process, and lets you create substantially complicated circuits out of nothing in
no time.</p>

<p>Another nice bit about Nand2Tetris is that it has much to offer to people at various skill levels. I entered the
course having never written a line of assembly, nor did I have much knowledge about compilers and virtual machines, but
I <em>did</em> have a reasonable amount of software engineering experience and at least a vague understanding of the
aforementioned components: the course ended up perfect, though I suspect that it’s mostly aimed at people in my
situation. Still, I can see it being useful even to greybeards with a nuanced knowledge of architectures, compilers,
and operating systems, simply because it does such a good job of tying them all together in a <em>single coherent
project</em>. I can imagine myself giving it another pass a couple of years from now, taking each of the projects further
and refreshing myself on the overview it provides.</p>

<p>Finally, the course is lightweight: the book comes in at just under 300 pages, and that’s with <em>twelve</em> sections that
collectively cover all of the vital components of a rudimentary computer. As a result, it doesn’t delve terribly far
into any one of them; you won’t implement many elementary chips, the authors intentionally skip over involved
problems like hardware multiplication, the computer won’t have a filesystem, you won’t come anywhere near hardware
acceleration, networking isn’t covered, and the high-level language you develop is highly limited (both in syntax and
functionality). That’s the point. <em>The Elements of Computing Systems</em> tries to provide a general introduction to each
component and a coherent project that ties them all together – it’s not the place to go for an immersive foray
into any of them. On the upside, it underscore a wealth of questions which you’re then encouraged to explore on your
own.</p>

<p>Taking some notes (<a href="https://github.com/sevko/portfolio/tree/develop/books/nand2tetris/notes">I did</a>) for future
reference might be a good idea while you read.</p>

<p>N2T is, in my opinion, a high quality must-read for software engineers. Can’t recommend it enough.</p>

<h2 id="a-note-on-requisites">a note on requisites</h2>
<p>This course is <em>not</em> for the amateur programmer. While the hardware chapters, the projects for which primarily consist
of implementing chips using an HDL, or hardware description language, don’t require any prior experience with anything,
the software sections involve the creation of reasonably complicated software in your programming language of choice. A
solid grasp of recursion is necessary for parsing, tokenization would probably be hell without a knowledge of regex,
and the compilers require some engineering acumen to implement cleanly – plus, it might be nice to have a vague
understanding of all the various components of a computer’s hardware and software going into the course, so that it
clarifies and refines your understanding of the various moving parts instead of simply introducing a bunch of
theretofore unheard-of concepts that, as a result, might be difficult to appreciate. I hope someone proves me wrong,
though!</p>

<h2 id="vim-syntax-files">vim syntax files</h2>
<p>As a complete aside, you’ll work with a number of ad-hoc languages throughout the course: <em>HDL</em>, <em>Hack</em> assembly,
<em>Hack</em> virtual machine language, and <em>Jack</em>. I’m a Vim user and got a little tired of the lack of syntax highlighting,
so wrote up a <a href="https://github.com/sevko/vim-nand2tetris-syntax">minimalist plugin</a> to provide it.</p>
>
				</content>
				<pubDate>Thu, 01 Jan 2015 21:00:00 +0000</pubDate>
				<link>http://sevko.io/articles/nand-2-tetris</link>
				<guid isPermaLink="true">http://sevko.io/articles/nand-2-tetris</guid>
			</item>
		
			<item>
				<title>prime number spirals</title>
				
					<category>math></category>
				
					<category>visualizations></category>
				
					<category>prime numbers></category>
				
					<category>javascript></category>
				
				<description>prime number spirals
Prime number spirals are visualizations of the distribution of prime numbers that underscore their frequent occurrences
along certain polynomials. They’re conceptually simple, yet create order out of the apparent chaos of primes and are
fairly beautiful. We’ll explore the Ulam and Sacks spirals, some of their underlying theory,
and algorithms to render each.

</description>
				<image>
					<url>http://www.w3schools.com/images/logo.gif</url>
					<title>An Ulam prime-number spiral.</title>
					<link>http://files.sevko.io/img/thumbnails/prime_number_spiral.png</link>
				</image>
				<content type="html">
					
						<b>Warning:</b> this post contains math blocks rendered with the
						<a href="http://www.mathjax.org/">MathJax</a> JavaScript library. If you're using an RSS reader or
						otherwise have Javascript disabled, none of them will display, so you should instead read this article at
						its <a href="http://sevko.io/articles/prime-number-spirals">source</a>.
					
					<h1 id="prime-number-spirals">prime number spirals</h1>
<p>Prime number spirals are visualizations of the distribution of prime numbers that underscore their frequent occurrences
along certain polynomials. They’re conceptually simple, yet create order out of the apparent chaos of primes and are
fairly beautiful. We’ll explore the Ulam and Sacks spirals, some of their underlying theory,
and algorithms to render each.</p>

<h2 id="ulam-spiral">Ulam spiral</h2>
<p>The story has it that <a href="http://en.wikipedia.org/wiki/Stanislaw_Ulam">Stanislaw Ulam</a>, a Polish-American mathematician of
<a href="http://en.wikipedia.org/wiki/Teller%E2%80%93Ulam_design">thermonuclear</a>
<a href="http://en.wikipedia.org/wiki/History_of_the_Teller%E2%80%93Ulam_design">fame</a><sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>, sat in a presentation of a
“long and very boring paper” at a 1963 scientific conference. After some time, he began doodling (the hallmark of great
genius), first writing out the first few positive integers in a counter-clockwise spiral, and then circling all of
the prime numbers. And he noticed something that he’d later formulate as “a strongly nonrandom appearance.” Even on
a small scale – say, the first 121 integers, which form a 11x11 grid – it’s visible that many primes align along
certain diagonal lines.</p>

<p><img src="http://files.sevko.io/prime_number_spirals/small_ulam_spiral.png" alt="An Ulam spiral consisting of the first 121 natural numbers" /></p>

<p>Ulam later used <a href="http://en.wikipedia.org/wiki/MANIAC_II">MANIAC II</a>, a first-generation computer built for
<a href="http://en.wikipedia.org/wiki/Los_Alamos_Scientific_Laboratory">Los Alamos National Laboratory</a> in 1957, to generate
images of the first 65,000<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup> integers. The following spiral contains the first 360,000
(600x600):</p>

<p><img src="http://files.sevko.io/prime_number_spirals/big_ulam_spiral.png" alt="An Ulam spiral consisting of the first 360,000 natural numbers." /></p>

<p>Look closely, and we see much more than just white noise.</p>

<h2 id="sacks-spiral">Sacks spiral</h2>

<p>A software engineer named Robert Sacks devised a variant of the Ulam spiral in 1994. Unlike Ulam’s, Sacks’s spiral
distributes integers along an <a href="http://en.wikipedia.org/wiki/Archimedean_spiral">Archimedean spiral</a>, or a function of
the polar form <script type="math/tex">r = a + b\theta</script>. Sacks discarded <script type="math/tex">a</script> (which just controls the offset of the starting point of the curve
from the pole) and used <script type="math/tex">b=\frac{1}{2\pi}</script>, leaving <script type="math/tex">r = \frac{\theta}{2\pi}</script>; he then plotted the squares of all
the natural numbers – <script type="math/tex">{1, 4, 9, 16, 25, ...}</script> – on the intersections of the spiral and the polar axis, and filled
in the points between squares along the spiral, drawing them equidistant from one another.</p>

<p><img src="http://files.sevko.io/prime_number_spirals/big_sacks_spiral.png" alt="A Sacks spiral consisting of the first 22,800 natural numbers." /></p>

<h1 id="prime-generating-polynomials">prime-generating polynomials</h1>

<p>The reason why we see ghostly diagonals is that some polynomials, informally called
<a href="http://mathworld.wolfram.com/Prime-GeneratingPolynomial.html">prime-generating polynomials</a>, have aberrantly high
occurrences of prime numbers. <script type="math/tex">n^2 + n + 41</script>, for instance, patented by
<a href="http://en.wikipedia.org/wiki/Leonhard_Euler">Leonhard Euler</a> in 1772, is prime for all <script type="math/tex">n</script> in the range <script type="math/tex">[0, 39]</script>,
yielding <script type="math/tex">43, 47, 53, 61, ..., 1523, 1601</script>. A variant is <script type="math/tex">n^2 - n + 41</script>, proposed by
<a href="http://en.wikipedia.org/wiki/Adrien-Marie_Legendre">Adrien-Marie Legendre</a> in 1798, which is prime in <script type="math/tex">[0, 40]</script>.
Here are several others, as taken at random from
<a href="http://mathworld.wolfram.com/Prime-GeneratingPolynomial.html">Wolfram Mathworld</a>:</p>

<script type="math/tex; mode=display">\frac{1}{4}(n^5 - 133n^4 + 6729n^3 - 158379n^2 + 1720294n - 6823316)\\
\frac{1}{36}(n^6 - 126n^5 + 6217n^4 - 153066n^3 + 1987786n^2 - 13055316n + 34747236)\\
n^4 - 97n^3 + 3294n^2 - 45458n + 213589\\
n^5 - 99n^4 + 3588n^3 - 56822n^2 + 348272n - 286397</script>

<p>In the case of the rectangular Ulam spiral, these polynomials appear as diagonal lines. They were known about since
1772, if not earlier, and a prime-number spiral was hinted at twice before Ulam published his. In 1932 (31 years
earlier before Ulam!), <a href="http://en.wikipedia.org/wiki/Laurence_Monroe_Klauber">Laurence M. Klauber</a>, a herpetologist
primarily focused on the study of rattlesnakes, presented a method of using a spiral grid to identify prime-generating
polynomials to the
<a href="http://en.wikipedia.org/wiki/Mathematical_Association_of_America">Mathematical Association of America</a>. The second
frequently-cited mention of prime spirals came from <a href="http://en.wikipedia.org/wiki/Arthur_C._Clarke">Arthur C. Clarke</a>,
a British science-fiction writer, whose <a href="http://en.wikipedia.org/wiki/The_City_and_the_Stars"><em>The City and the Stars</em></a>
(1956) describes a protagonist, Jeserac, as “[setting] up the matrix of all possible integers, and [starting] his
computer stringing the primes across its surface as beads might be arranged at the intersections of a mesh.” In my
opinion, the second mention is fairly ambiguous, but the fact stands that, by the time Ulam published his famous
spiral, a general understanding of prime-generating polynomials existed and people were considering ways of visualizing
them. Thus, it’s perhaps a little disingenuous to suggest that he stumbled across it when “doodling” (something
intricate) at random – there may have been some method to it.</p>

<h1 id="rendering-the-spirals">rendering the spirals</h1>

<p>I was introduced to prime number spirals about a year ago, by <a href="https://www.youtube.com/watch?v=iFuR97YcSLM">a video</a>
on the excellent <a href="https://www.youtube.com/channel/UCoxcjq-8xIDTYp3uz647V5A">Numberphile</a>. I immediately jumped
into hacking together a Python script to render the spirals on my own, because it’s both tremendously easy and very
visually rewarding. I’ll revisit the implementation, this time in Javascript. I’m not going to show all of the
necessary code (like HTML markup/CSS styles) in the interest of brevity, but the zipped files are linked to at the end
of the post.</p>

<h2 id="canvas-setup">canvas setup</h2>

<p>Let’s outline our interface. We’ll define functions <code>ulamSpiral(numLayers)</code> and <code>sacksSpiral(numLayers)</code>, where
the argument <code>numLayers</code> is the number of revolutions in the spiral, or effectively the number of rings that it contains. Both
functions need to set the height and width of the canvas according to <code>numLayers</code>, and require a function
<code>drawPixel(x, y)</code> to plot pixels. Note that we’ll want <code>drawPixel()</code> to treat the <em>centroid</em> of the canvas as its
origin, so that <code>drawPixel(0, 0)</code> plots a point at its center and <em>not</em> the top-left corner. Because both the canvas
dimensions and the offset used by <code>drawPixel()</code> are dependent on <code>numLayers</code>, we’ll bundle them them into a function
called <code>setupCanvas()</code>.</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">setupCanvas</span><span class="p">(</span><span class="nx">numLayers</span><span class="p">){</span>
	<span class="s2">&quot;use strict&quot;</span><span class="p">;</span>

	<span class="kd">var</span> <span class="nx">sideLen</span> <span class="o">=</span> <span class="nx">numLayers</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kd">var</span> <span class="nx">canvas</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s2">&quot;canvas&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
	<span class="nx">canvas</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span><span class="s2">&quot;width&quot;</span><span class="p">,</span> <span class="nx">sideLen</span><span class="p">);</span>
	<span class="nx">canvas</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span><span class="s2">&quot;height&quot;</span><span class="p">,</span> <span class="nx">sideLen</span><span class="p">);</span>

	<span class="kd">var</span> <span class="nx">context</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="s2">&quot;2d&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="kd">function</span> <span class="nx">drawPixel</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">){</span>
		<span class="nx">context</span><span class="p">.</span><span class="nx">fillRect</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">numLayers</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">numLayers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">};</span>
<span class="p">}</span></code></pre></div>

<p>Note that we set <code>sideLen</code> equal to <code>numLayers * 2 + 1</code>, rather than only <code>numLayers * 2</code>, because we need to account for the
row/column containing the origin of the spiral, which is not technically a ring. Now, we can use <code>setupCanvas()</code> to
both set the canvas dimensions, and return a <code>drawPixel()</code> that takes advantage of closure to access all of the
variables (<code>numLayers</code>, <code>context</code>) that it needs. Also, to draw a single pixel, we’re calling <code>fillRect()</code> with a
width and height of 1 – the canvas unfortunately doesn’t have (or perhaps just doesn’t expose) a single pixel-plotting
function. Finally, to test the primality of our values, we’ll use <a href="https://www.npmjs.org/~kenan">Kenan Yildirim</a>’s
<a href="https://www.npmjs.org/package/primality">primality</a> library, which provides <code>primality(val)</code>.</p>

<h2 id="ulam-algorithm">Ulam algorithm</h2>

<p>The dull stuff aside, we can begin implementing <code>ulamSpiral()</code>. The general algorithm will run as follows:</p>

<ol>
  <li>Use variables <code>x</code>, <code>y</code>, and <code>currValue</code> to track the position and value of the current point – the “head” of the
spiral.</li>
  <li>Trace out the square spirals by incrementing/decrementing <code>x</code> and <code>y</code>, while incrementing <code>currValue</code>.</li>
  <li>After the head of the spiral moves, if <code>currValue</code> is prime, plot a pixel at (<code>x</code>, <code>y</code>).</li>
</ol>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">ulamSpiral</span><span class="p">(</span><span class="nx">numLayers</span><span class="p">){</span>
	<span class="s2">&quot;use strict&quot;</span><span class="p">;</span>

	<span class="kd">var</span> <span class="nx">drawPixel</span> <span class="o">=</span> <span class="nx">setupCanvas</span><span class="p">(</span><span class="nx">numLayers</span><span class="p">);</span>

	<span class="kd">var</span> <span class="nx">currValue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="kd">function</span> <span class="nx">drawLine</span><span class="p">(</span><span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">,</span> <span class="nx">len</span><span class="p">){</span>
		<span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">pixel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">pixel</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">pixel</span><span class="o">++</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="nx">primality</span><span class="p">(</span><span class="nx">currValue</span><span class="o">++</span><span class="p">)){</span>
				<span class="nx">drawPixel</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="nx">x</span> <span class="o">+=</span> <span class="nx">dx</span><span class="p">;</span>
			<span class="nx">y</span> <span class="o">+=</span> <span class="nx">dy</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">layer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">layer</span> <span class="o">&lt;=</span> <span class="nx">numLayers</span><span class="p">;</span> <span class="nx">layer</span><span class="o">++</span><span class="p">,</span> <span class="nx">len</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">){</span>
		<span class="nx">drawLine</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="nx">drawLine</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span><span class="p">);</span>
		<span class="nx">drawLine</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">len</span><span class="p">);</span>
		<span class="nx">drawLine</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>We simply iterate <code>numLayers + 1</code> times, drawing rectangular layers – the spiral – as we go. I couldn’t think of a
better solution than using a function <code>drawLine()</code>, which accepts a direction (<code>dx</code> and <code>dy</code>, one of which should be
0), and a <code>length</code> to draw four different straight lines (perhaps it can somehow be done in one elegant loop?).</p>

<h2 id="sacks-algorithm">Sacks algorithm</h2>

<p>The Sacks spiral is a little more mathematically interesting because it relies (somewhat) on polar equations. Our
algorithm:</p>

<ol>
  <li>Iterate <code>numLayers</code> times.</li>
  <li>For each iteration, draw the values between the current square, <script type="math/tex">n ^ 2</script>, and the next, <script type="math/tex">n + 1 ^ 2</script>. Since
<script type="math/tex">(n + 1)^2 - n^2 = n^2 + 2n + 1 - n^2 = 2n + 1</script>, there are <script type="math/tex">2n + 1</script> points per iteration of <script type="math/tex">n</script>.</li>
  <li>Render each prime point by calculating its angle off the polar axis (the aligned squares), then its radius, or
distance from the pole, and then using trigonometry to solve for its cartesian coordinates.</li>
</ol>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">sacksSpiral</span><span class="p">(</span><span class="nx">numLayers</span><span class="p">){</span>
	<span class="s2">&quot;use strict&quot;</span><span class="p">;</span>

	<span class="kd">var</span> <span class="nx">drawPixel</span> <span class="o">=</span> <span class="nx">setupCanvas</span><span class="p">(</span><span class="nx">numLayers</span><span class="p">);</span>

	<span class="kd">var</span> <span class="nx">currValue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">layer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">layer</span> <span class="o">&lt;=</span> <span class="nx">numLayers</span><span class="p">;</span> <span class="nx">layer</span><span class="o">++</span><span class="p">){</span>
		<span class="kd">var</span> <span class="nx">numPoints</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">layer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="kd">var</span> <span class="nx">angle</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">/</span> <span class="nx">numPoints</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">point</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">point</span> <span class="o">&lt;=</span> <span class="nx">numPoints</span><span class="p">;</span> <span class="nx">point</span><span class="o">++</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="nx">primality</span><span class="p">(</span><span class="nx">currValue</span><span class="o">++</span><span class="p">)){</span>
				<span class="kd">var</span> <span class="nx">theta</span> <span class="o">=</span> <span class="nx">point</span> <span class="o">*</span> <span class="nx">angle</span><span class="p">;</span>
				<span class="kd">var</span> <span class="nx">radius</span> <span class="o">=</span> <span class="nx">layer</span> <span class="o">+</span> <span class="nx">point</span> <span class="o">/</span> <span class="nx">numPoints</span><span class="p">;</span>
				<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span><span class="p">(</span><span class="nx">theta</span><span class="p">)</span> <span class="o">*</span> <span class="nx">radius</span><span class="p">;</span>
				<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="nx">theta</span><span class="p">)</span> <span class="o">*</span> <span class="nx">radius</span><span class="p">;</span>
				<span class="nx">drawPixel</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">y</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>To calculate the polar angle of any point, we first solve for the angle between subsequent points
(<code>var angle = 2 * Math.PI / numPoints;</code>), and then multiply it by the fraction of the current rotation of the spiral
that the point lies at (<code>var theta = point * angle;</code>). We’ll also <code>Math.floor()</code> the coordinates sent to <code>drawPixel()</code>,
because, after the various trigonometic operations they’re likely decimals rather than integers and cause blurred
canvas reading.</p>

<p>That’s all! For more reading on prime-number spirals, I recommend this <a href="http://www.numberspiral.com/">in-depth article</a>
by Robert Sacks himself, and another <a href="http://www.dcs.gla.ac.uk/~jhw/spirals/">write-up</a> of algorithms used to render
them.</p>

<p>Download all of the source code <a href="http://files.sevko.io/prime_number_spirals/prime_number_spirals.zip">here</a>, or view it
on <a href="https://github.com/sevko/portfolio/tree/develop/visualizations/prime_number_spirals">Github</a>.</p>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>Ulam is also well-known for contributing to the
<a href="http://en.wikipedia.org/wiki/Manhattan_Project">Manhattan Project</a>, proponing the
<a href="http://en.wikipedia.org/wiki/Monte_Carlo_method">Monte Carlo method</a> of computation, and exploring
<a href="http://en.wikipedia.org/wiki/Project_Orion_(nuclear_propulsion)">spaceships propelled by nuclear explosions</a>,
amongst a large number of other things. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>Assuming that Ulam began rendering his spiral with the integer 1 (instead of something like 41, which is also
common), I suspect that the generated images had exactly 65,025 integers. 65,000 integers implies as many pixels,
the square root – the Ulam spiral is inherently square – of which is 254.95, which obviously isn’t a valid image
height/width. Thus, we round to 255, and square for 65,025. <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>
>
				</content>
				<pubDate>Wed, 01 Oct 2014 22:00:00 +0100</pubDate>
				<link>http://sevko.io/articles/prime-number-spirals</link>
				<guid isPermaLink="true">http://sevko.io/articles/prime-number-spirals</guid>
			</item>
		
			<item>
				<title>power set algorithms</title>
				
					<category>math></category>
				
					<category>sets></category>
				
					<category>algorithms></category>
				
					<category>python></category>
				
				<description>power sets
The power set of a set is the set of all its subsets, or a collection of all the different combinations of items
contained in that given set: in this write-up, we’ll briefly explore the math behind power sets, and derive and compare
three different algorithms used to generate them.

</description>
				<image>
					<url>http://www.w3schools.com/images/logo.gif</url>
					<title>A power set lattice.</title>
					<link>http://files.sevko.io/img/thumbnails/power_set.png</link>
				</image>
				<content type="html">
					
						<b>Warning:</b> this post contains math blocks rendered with the
						<a href="http://www.mathjax.org/">MathJax</a> JavaScript library. If you're using an RSS reader or
						otherwise have Javascript disabled, none of them will display, so you should instead read this article at
						its <a href="http://sevko.io/articles/power-set-algorithms">source</a>.
					
					<h1 id="power-sets">power sets</h1>
<p>The power set of a set is the set of all its subsets, or a collection of all the different combinations of items
contained in that given set: in this write-up, we’ll briefly explore the math behind power sets, and derive and compare
three different algorithms used to generate them.</p>

<h2 id="sets-primer">sets: primer</h2>
<p>To refresh our memories: a <a href="http://en.wikipedia.org/wiki/Set_(mathematics)">set</a>, the building block of <a href="http://en.wikipedia.org/wiki/Set_theory">set
theory</a><sup id="link1"><a href="#note1">1</a></sup>, is a collection of any number of
unique objects whose order does not matter. A set is expressed using bracket notation, like <script type="math/tex">\{1, 2, 3\}</script>, and an
empty, or <strong>null</strong>, set is represented using either of <script type="math/tex">\emptyset</script> and <script type="math/tex">\{\}</script>. Because sets are order-agnostic, we
can say that the <script type="math/tex">\{1, 2, 3\}</script> and <script type="math/tex">\{3, 1, 2\}</script> are equal, and, because they contain only distinct members,
something like <script type="math/tex">\{1, 1, 2\}</script> is invalid.</p>

<h2 id="subsets-and-the-power-set">subsets and the power set</h2>
<p>The <a href="http://en.wikipedia.org/wiki/Subset">subset</a> of a set is any combination (the null set included) of its members,
such that it is contained inside the superset; <script type="math/tex">\{a, b\}</script>, then, is a subset of <script type="math/tex">\{a, b, c\}</script>, while <script type="math/tex">\{a, d\}</script>
is not. If a subset contains <em>all</em> of the members of the parent set (ie, it’s a copy), we call it an <strong>improper</strong>
subset – otherwise, it’s <strong>proper</strong>. Finally, the <a href="http://en.wikipedia.org/wiki/Power_set">power set</a> of a set is the
collection of all of its subsets, so the power set of <script type="math/tex">\{a, b, c\}</script> is:</p>

<script type="math/tex; mode=display">\{
    \{\},
    \{a\},
    \{b\},
    \{c\},
    \{a, b\},
    \{a, c\},
    \{b, c\},
    \{a, b, c\}
\}</script>

<h2 id="the-cardinality-of-a-power-set">the cardinality of a power set</h2>
<p>The length, or <a href="http://en.wikipedia.org/wiki/Cardinality">cardinality</a>, of a power set is <script type="math/tex">2^n</script>, where <script type="math/tex">n</script> is the
cardinality of the original set, so the number of subsets of something like <script type="math/tex">\{a, b, c\} (n=3)</script> is 8 <script type="math/tex">(2^{n=3})</script>.
Two ways of informally proving that property:</p>

<ol>
  <li>when creating a subset of a given set, we iterate over the members of the given set and choose whether each one
will or will not be in the subset. Since there are 2 possible outcomes of each choice (the member either is or
isn’t chosen) and there are <script type="math/tex">n</script> elements, there must be <script type="math/tex">2^n</script> subsets.</li>
  <li>when adding an element to a set, to update its power set, you must create a copy of each of its existing subsets
with the new element included. We’ll use this to implement our succinct second algorithm.</li>
</ol>

<p><strong>Note</strong>: the following algorithms are accompanied by Python implementations. To keep things simple, and because the
algorithms are language-independent, I avoided using Python-specific built-ins (like <code>yield</code>) and functions (like
<code>list.extend()</code>) that don’t have clear equivalents in most other languages, even though they would’ve made some code
much cleaner. Also, even though we’re dealing with sets, we’ll use lists (arrays) under the assumption that they
contain distinct elements.</p>

<h1 id="algorithm-1-recursive-k-subsets">algorithm 1: recursive k-subsets</h1>
<p>This was my first stab at an algorithm that, given a set, returns its power set, and surprise! It’s the least
intuitive and most inelegant of the three. We begin by writing a recursive function <code>k_subsets()</code> to find all of a
set’s subsets of cardinality <script type="math/tex">k</script> (a.k.a. its <a href="http://mathworld.wolfram.com/k-Subset.html"><script type="math/tex">k</script>-subsets</a>):</p>

<h2 id="generating-k-subsets">generating k-subsets</h2>

<ol>
  <li>Given a set of length <script type="math/tex">n</script> and a desired subset of length <script type="math/tex">k</script>, iterate over the first <script type="math/tex">n - k + 1</script> elements.</li>
  <li>For each element, make a recursive call to retrieve the <script type="math/tex">(k-1)</script>-subsets for the remainder of the array (all
elements after the current one).</li>
  <li>Append the element to each <script type="math/tex">(k-1)</script>-subset, and return these subsets.</li>
</ol>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">k_subsets</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">set_</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[[]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">subsets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">set_</span><span class="p">)</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="n">k_subsets</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">set_</span><span class="p">[</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]):</span>
                <span class="n">subsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subset</span> <span class="o">+</span> <span class="p">[</span><span class="n">set_</span><span class="p">[</span><span class="n">ind</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">subsets</span></code></pre></div>

<h2 id="from-k-subsets-to-power-set">from k-subsets to power set</h2>

<p>With the ability to generate any <script type="math/tex">k</script>-subset, the key to creating a power set is finding the <script type="math/tex">k</script>-subsets for all
valid <script type="math/tex">k</script>, which lie in the range <script type="math/tex">[0, n]</script> (<script type="math/tex">n</script>, again, is the cardinality of the superset)!</p>

<ol>
  <li>For any <script type="math/tex">k</script> in <script type="math/tex">[0, n]</script>:</li>
  <li>find the set’s <script type="math/tex">k</script>-subsets</li>
</ol>

<p>We’ll introduce a wrapper function, <code>power_set()</code>, in which we’ll nest a slightly modified <code>k_subsets()</code> that takes
advantage of closures.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">power_set_1</span><span class="p">(</span><span class="n">set_</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">k_subsets</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">start_ind</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[[]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subsets</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">start_ind</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">set_</span><span class="p">)</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="n">k_subsets</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">subsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subset</span> <span class="o">+</span> <span class="p">[</span><span class="n">set_</span><span class="p">[</span><span class="n">ind</span><span class="p">]])</span>
            <span class="k">return</span> <span class="n">subsets</span>

    <span class="n">subsets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">set_</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="n">k_subsets</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">subsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">subsets</span></code></pre></div>

<h1 id="algorithm-2-iterative-appending">algorithm 2: iterative appending</h1>

<p>The second algorithm relies on our second informal proof of sets’ cardinality: whenever an element is added to a set,
it must be added to copies of all the subsets in its current power set to form the new one. Thus:</p>

<ol>
  <li>Start with an empty set, <script type="math/tex">\{\}</script>, and its power-set, <script type="math/tex">\{\{\}\}</script>.</li>
  <li>For every element inside the superset:</li>
  <li>Create a copy of every set in the current power-set</li>
  <li>Add the element to each one.</li>
  <li>Add the copies to the current power-set.</li>
</ol>

<p>Like so:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">power_set_2</span><span class="p">(</span><span class="n">set_</span><span class="p">):</span>
    <span class="n">subsets</span> <span class="o">=</span> <span class="p">[[]]</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">set_</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subsets</span><span class="p">)):</span>
            <span class="n">subsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subsets</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">element</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">subsets</span></code></pre></div>

<h1 id="algorithm-3-binary-representation">algorithm 3: binary representation</h1>

<p>The third algorithm is a clever hack, and relies on the binary representation of an incremented number to construct
subsets. In our first proof of the cardinality of a power set, we iterated over each element of an argument set and
made a choice with two possible outcomes (the element either was or wasn’t a member of the subset): <script type="math/tex">\underbrace{2 \times 2 \times ... \times 2}_{n} = 2^n</script>. Let’s consider an integer of <script type="math/tex">n</script>-bits: it has <script type="math/tex">2^n</script>
possible values in the range <script type="math/tex">[0, 2^n - 1]</script>, meaning that we can use it to represent <script type="math/tex">2^n</script> distinct arrangements of
<script type="math/tex">n</script> bits. Hmm…</p>

<ol>
  <li>Iterate over the range <script type="math/tex">[0, 2^n - 1]</script>.</li>
  <li>For every value, examine each of its <script type="math/tex">n</script> bits.</li>
  <li>If the <script type="math/tex">k</script>th bit has a value of 1, add the <script type="math/tex">k</script>th value of the superset to the current subset.</li>
</ol>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">is_bit_flipped</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">bit</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;&gt;</span> <span class="n">bit</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">power_set_3</span><span class="p">(</span><span class="n">set_</span><span class="p">):</span>
    <span class="n">subsets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="nb">len</span><span class="p">(</span><span class="n">set_</span><span class="p">)):</span>
        <span class="n">new_subset</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">set_</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">is_bit_flipped</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">bit</span><span class="p">):</span>
                <span class="n">new_subset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">set_</span><span class="p">[</span><span class="n">bit</span><span class="p">])</span>
        <span class="n">subsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_subset</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">subsets</span></code></pre></div>

<hr />

<p><span id="note1"><a href="#link1">1</a></span>: (completely tangentially) whenever I mention set theory I can’t help but think of
the infamous <a href="http://en.wikipedia.org/wiki/Principia_Mathematica">Principia Mathematica</a>: a staggering, three-volume
attempt to axiomatize all of mathematics, published by <a href="http://en.wikipedia.org/wiki/Bertrand_Russell">Bertrand
Russell</a> and <a href="http://en.wikipedia.org/wiki/Alfred_North_Whitehead">Alfred North
Whitehead</a> in 1910-‘13, that relied heavily on sets. It’s
notorious, amongst other things, for proving <script type="math/tex">1 + 1 = 2</script> in no less than 379 pages. Check it out.</p>
>
				</content>
				<pubDate>Sun, 21 Sep 2014 22:00:00 +0100</pubDate>
				<link>http://sevko.io/articles/power-set-algorithms</link>
				<guid isPermaLink="true">http://sevko.io/articles/power-set-algorithms</guid>
			</item>
		
	</channel>
</rss>
